# 心理分析系统 - 端到端全栈架构设计 v1.0

> **版本**: v1.1
> **文档类型**: 全栈架构设计文档
> **创建日期**: 2026-02-08
> **修订日期**: 2026-02-09
> **状态**: Draft
> **修订说明**: 基于技术评审反馈修订（Relationship节点化、SSE响应协议、服务依赖明确化、启动处理器、完整性校验、版本管理策略、跨库同步、Fallback决策树、风险补充）
> **关联文档**:
> - 心理分析系统_产品需求文档_v2.0.md
> - 心理分析系统_P0阶段交互需求设计_v2.0.md
> - 元本体数据模型需求文档_v1.0.md
> - Neo4j_RAG技术调研报告_完整版.md
> - 数据库服务快速访问指南.md

---

## 目录

1. [需求理解与约束分析](#1-需求理解与约束分析)
   - 1.1 业务背景
   - 1.2 核心用例
   - 1.3 约束条件
   - 1.4 分阶段实施策略
2. [系统总体架构](#2-系统总体架构)
   - 2.1 架构总览图
   - 2.2 分层架构说明
   - 2.3 技术选型与对比分析
3. [后端架构设计](#3-后端架构设计)
   - 3.1 后端分层架构
   - 3.2 服务模块划分（SysML组合图）
   - 3.3 各服务能力描述与边界
   - 3.4 服务间依赖关系
4. [前端架构设计](#4-前端架构设计)
   - 4.1 前端分层架构
   - 4.2 模块划分与路由设计
   - 4.3 状态管理策略
   - 4.4 图可视化方案
5. [数据模型设计（ER图）](#5-数据模型设计er图)
   - 5.1 PostgreSQL关系模型
   - 5.2 Neo4j图模型
   - 5.3 存储策略与数据流
6. [接口协议设计](#6-接口协议设计)
   - 6.1 API总览
   - 6.2 统一响应格式
   - 6.3 各服务API定义
7. [核心场景交互设计](#7-核心场景交互设计)
   - 7.1 用例图
   - 7.2 核心场景序列图
   - 7.3 状态转换图
8. [部署架构设计](#8-部署架构设计)
   - 8.1 部署拓扑图
   - 8.2 基础设施配置
9. [测试策略与验收标准](#9-测试策略与验收标准)
   - 9.1 测试分层策略
   - 9.2 各服务测试用例与验收标准
10. [演进路径](#10-演进路径)
    - 10.1 P0阶段实现范围
    - 10.2 P1/P2阶段扩展预留
    - 10.3 P3阶段平台化考量
11. [风险与决策记录](#11-风险与决策记录)
    - 11.1 关键架构决策记录（ADR）
    - 11.2 风险识别与缓解

---

## 1. 需求理解与约束分析

### 1.1 业务背景

本系统是一个**基于多模态输入的场景化心理分析系统**，通过分析多模态数据（文字、对话、图片、视频、文档），提取人物心理特征，生成专业的分析报告。

系统包含**10个核心能力域**，按照3个阶段分步实施：

| 阶段 | 定位 | 核心能力域 |
|------|------|-----------|
| **P0（基础设施）** | 构建通用心理学本体和知识库 | 模型管理与调度、提示词管理、元本体体系、知识图谱与语义查询 |
| **P1/P2（分析功能）** | 基于本体和知识库开发场景化分析 | 场景模板管理、通用分析引擎、报告生成、证据链与推理追溯、多模态输入处理 |
| **P3（系统管理）** | 完善用户和权限管理 | 用户权限管理 |

**核心设计理念**：
- **元本体是Schema，知识图谱是Data**：元本体定义心理模型的结构，知识图谱存储具体的知识实例
- **分析与构建分离**：场景化分析使用通用分析引擎，本体/知识构建直接使用模型调度
- **知识参与方式**：通过RAG（检索增强生成）方式，在分析时动态检索相关知识

### 1.2 核心用例

```mermaid
graph LR
    subgraph 用户角色
        Expert["心理学专家"]
        DomainExpert["领域专家"]
        Admin["系统管理员"]
        Analyst["分析人员"]
    end

    subgraph P0阶段用例
        UC1["构建元本体模型"]
        UC2["管理知识图谱"]
        UC3["管理提示词模板"]
        UC4["配置AI模型"]
    end

    subgraph P1_P2阶段用例
        UC5["执行场景化分析"]
        UC6["管理场景模板"]
        UC7["生成分析报告"]
        UC8["追溯证据链"]
        UC9["上传多模态文档"]
    end

    Expert --> UC1
    Expert --> UC2
    Expert --> UC3
    DomainExpert --> UC1
    DomainExpert --> UC2
    Admin --> UC4
    Admin --> UC3
    Analyst --> UC5
    Analyst --> UC7
    Analyst --> UC8
    Analyst --> UC9
    DomainExpert --> UC6
```

### 1.3 约束条件

#### 1.3.1 性能约束

| 指标 | P0阶段 | P1/P2阶段 | P3阶段 |
|------|--------|-----------|--------|
| 页面响应时间 | < 2s | < 2s | < 2s |
| 文档上传 | - | < 5s | < 5s |
| 分析处理 | - | < 60s | < 60s |
| 报告生成 | - | < 10s | < 10s |
| 并发用户数 | 10 | 10 | 100+ |
| 图谱查询响应 | < 2s | < 2s | < 1s |

#### 1.3.2 技术约束

- **前端**：React 18+、Ant Design 5.x、桌面端优先（最小分辨率 1200x768）
- **后端**：Python 3.8+、FastAPI、LangChain
- **数据库**：已部署 Neo4j 5.x、Milvus、PostgreSQL（服务器 192.168.176.128）
- **AI模型**：支持多模型提供商（GPT-4o、Claude 3.5、Gemini 3 Pro、豆包、通义千问等）
- **RAG方案**：采用 Method 5（Function Calling + Neo4j + Auto Cypher Fallback），经技术调研验证

#### 1.3.3 质量约束

- LLM调用成功率 >= 95%
- 自然语言意图理解准确率 >= 85%
- 查询工具调用准确率 >= 90%
- Fallback机制触发成功率 = 100%
- 分析完成率 >= 95%

### 1.4 分阶段实施策略

```mermaid
gantt
    title 心理分析系统实施路线图
    dateFormat  YYYY-MM
    axisFormat  %Y-%m

    section P0-基础设施
    模型管理与调度(P0-1)       :p01, 2026-02, 2026-04
    提示词管理系统(P0-2)       :p02, 2026-02, 2026-04
    元本体体系(P0-3)           :p03, 2026-03, 2026-05
    知识图谱与语义查询(P0-4)   :p04, 2026-03, 2026-05

    section P1_P2-分析功能
    场景模板管理(P1-1)         :p11, after p03, 2026-07
    通用分析引擎(P1-2)         :p12, after p01, 2026-08
    报告生成(P1-3)             :p13, after p12, 2026-09
    证据链与推理追溯(P1-4)     :p14, after p12, 2026-09
    多模态输入处理(P2-1)       :p21, after p13, 2026-10

    section P3-系统管理
    用户权限管理(P3-1)         :p31, after p21, 2026-12
```

---

## 2. 系统总体架构

### 2.1 架构总览图

```mermaid
graph TD
    subgraph 前端层["前端层 (React 18 + Ant Design 5.x)"]
        direction TB
        FE_Ontology["元本体管理模块"]
        FE_KG["知识图谱模块"]
        FE_Prompt["提示词管理模块"]
        FE_Model["模型管理模块"]
        FE_Scene["场景模板模块<br/>(P1预留)"]
        FE_Report["报告展示模块<br/>(P1预留)"]
    end

    subgraph 网关层["API网关层"]
        Gateway["FastAPI Gateway<br/>路由 / 认证 / 限流"]
    end

    subgraph 服务层["后端服务层 (Python + LangChain)"]
        direction TB
        SVC_Ontology["元本体服务"]
        SVC_KG["知识图谱服务"]
        SVC_Prompt["提示词服务"]
        SVC_Model["模型管理服务"]
        SVC_RAG["RAG查询服务<br/>(内部服务)"]
        SVC_Analysis["分析引擎服务<br/>(P1预留)"]
    end

    subgraph AI能力层["AI能力层"]
        direction TB
        LLM["LLM调度器<br/>GPT-4o / Claude / Gemini"]
        FC["Function Calling<br/>引擎"]
        CypherGen["Auto Cypher<br/>生成器"]
    end

    subgraph 数据层["数据持久层"]
        direction TB
        Neo4j["Neo4j 5.x<br/>图数据库<br/>本体 + 知识图谱"]
        PG["PostgreSQL<br/>关系数据库<br/>配置 + 业务数据"]
        Milvus["Milvus<br/>向量数据库<br/>(P2预留)"]
    end

    前端层 -->|RESTful API| 网关层
    网关层 --> 服务层
    服务层 --> AI能力层
    服务层 --> 数据层
    AI能力层 --> 数据层
```

### 2.2 分层架构说明

系统采用**四层架构**设计，各层职责清晰、边界明确：

| 层级 | 职责 | 核心技术 | P0实现 | P1+扩展 |
|------|------|---------|--------|---------|
| **前端层** | 用户交互、数据展示、图可视化 | React 18, Ant Design 5.x, G6 | 4个管理模块 | 场景分析、报告展示 |
| **API网关层** | 路由分发、认证鉴权、限流熔断 | FastAPI | 基础路由 | 认证、限流 |
| **服务层** | 业务逻辑、AI编排、数据处理 | Python, LangChain, Pydantic | 4个核心服务 + RAG内部服务 | 分析引擎、报告服务 |
| **数据层** | 数据持久化、图存储、向量检索 | Neo4j, PostgreSQL, Milvus | Neo4j + PostgreSQL | Milvus向量检索 |

**层间通信协议**：
- 前端 <-> 网关：RESTful HTTP/JSON（P0），GraphQL（P2预留）
- 网关 <-> 服务：Python模块内部调用（单体部署），HTTP（微服务部署预留）
- 服务 <-> 数据：Bolt协议（Neo4j）、TCP（PostgreSQL）、gRPC（Milvus）
- 服务 <-> AI：HTTP/SSE（LLM API调用）

### 2.3 技术选型与对比分析

#### 2.3.1 后端框架选型

| 维度 | FastAPI | Flask | Django |
|------|---------|-------|--------|
| 异步支持 | 原生async/await | 需扩展 | 部分支持 |
| 类型校验 | Pydantic内置 | 需手动 | 内置但较重 |
| API文档 | 自动生成OpenAPI | 需扩展 | 需扩展 |
| 性能 | 高（Starlette） | 中 | 中 |
| 学习曲线 | 低 | 低 | 高 |
| LangChain集成 | 原生兼容 | 兼容 | 兼容 |

**决策**：选择 **FastAPI**。理由：原生异步支持适配LLM长耗时调用；Pydantic类型校验与元本体Schema天然契合；自动生成OpenAPI文档降低前后端协作成本。

#### 2.3.2 前端框架选型

| 维度 | React 18 | Vue 3 |
|------|----------|-------|
| 生态成熟度 | 极高 | 高 |
| 图可视化库 | G6(AntV)、D3 | G6(AntV)、D3 |
| UI组件库 | Ant Design 5.x | Element Plus |
| 状态管理 | Zustand/Redux Toolkit | Pinia |
| TypeScript支持 | 优秀 | 优秀 |

**决策**：选择 **React 18 + Ant Design 5.x**。理由：与G6(AntV)同属蚂蚁生态，图可视化集成最佳；Ant Design Pro提供开箱即用的管理后台布局；社区资源丰富。

#### 2.3.3 RAG方案选型

基于Neo4j RAG技术调研报告的实验结论：

| 方法 | 准确率 | 成本(Token) | 边界识别 | 适用场景 |
|------|--------|------------|---------|---------|
| Method 1: 纯向量检索 | 中 | 低 | 差 | 文本相似度匹配 |
| Method 2: 纯Function Calling | 高 | 低(~845) | 中 | 结构化查询 |
| Method 4: Auto Cypher | 高 | 高(~1800) | 高 | 复杂图查询 |
| **Method 5: 混合Fallback** | **高** | **中** | **高(94.4%)** | **通用场景** |

**决策**：选择 **Method 5（Function Calling + Neo4j + Auto Cypher Fallback）**。理由：B组降级识别率94.4%，成本较Method 4节省56%，性能提升47%，满足PRD中FR-3.6.3的Fallback机制要求。

#### 2.3.4 数据库选型

| 数据库 | 用途 | 阶段 | 状态 |
|--------|------|------|------|
| **Neo4j 5.x** | 元本体Schema存储、知识图谱实例存储、图语义查询 | P0 | 已部署 |
| **PostgreSQL** | 系统配置、提示词模板、模型配置、用户数据、分析任务 | P0 | 已部署 |
| **Milvus** | 向量检索、文本语义匹配（RAG增强） | P2预留 | 已部署 |

---

## 3. 后端架构设计

### 3.1 后端分层架构

```mermaid
graph TD
    subgraph API层["API层 (FastAPI Router)"]
        direction TB
        Router_Ontology["ontology_router"]
        Router_KG["knowledge_router"]
        Router_Prompt["prompt_router"]
        Router_Model["model_router"]
    end

    subgraph Service层["Service层 (业务逻辑)"]
        direction TB
        Svc_Ontology["OntologyService"]
        Svc_KG["KnowledgeGraphService"]
        Svc_Prompt["PromptService"]
        Svc_Model["ModelService"]
        Svc_RAG["RAGQueryService"]
    end

    subgraph Domain层["Domain层 (领域模型)"]
        direction TB
        DM_Meta["元模型定义<br/>Level 0: Thing, RelType"]
        DM_Biz["业务元本体<br/>Level 1: Entity, Event..."]
        DM_Schema["Schema验证器<br/>Pydantic Models"]
    end

    subgraph Infra层["Infrastructure层 (基础设施)"]
        direction TB
        Repo_Neo4j["Neo4jRepository"]
        Repo_PG["PostgresRepository"]
        LLM_Client["LLMClientFactory"]
        FC_Engine["FunctionCallingEngine"]
        Cypher_Gen["CypherGenerator"]
        Startup["StartupHandler<br/>枚举注册 / Schema同步"]
    end

    API层 --> Service层
    Service层 --> Domain层
    Service层 --> Infra层
    Domain层 --> Infra层
```

**后端工程目录结构**：

```
backend/
├── app/
│   ├── main.py                    # FastAPI应用入口
│   ├── config.py                  # 全局配置
│   ├── api/                       # API层（路由定义）
│   │   ├── v1/
│   │   │   ├── ontology.py        # 元本体API
│   │   │   ├── knowledge.py       # 知识图谱API（含自然语言查询）
│   │   │   ├── prompt.py          # 提示词API
│   │   │   └── model.py           # 模型管理API
│   │   └── deps.py                # 依赖注入
│   ├── services/                  # Service层（业务逻辑）
│   │   ├── ontology_service.py
│   │   ├── knowledge_service.py
│   │   ├── prompt_service.py
│   │   ├── model_service.py
│   │   └── rag_service.py
│   ├── domain/                    # Domain层（领域模型）
│   │   ├── meta_model.py          # Level 0 元模型
│   │   ├── business_ontology.py   # Level 1 业务元本体
│   │   └── schemas.py             # Pydantic Schema定义
│   ├── infrastructure/            # Infrastructure层
│   │   ├── neo4j_repo.py          # Neo4j数据访问
│   │   ├── postgres_repo.py       # PostgreSQL数据访问
│   │   ├── llm_client.py          # LLM客户端工厂
│   │   ├── function_calling.py    # Function Calling引擎
│   │   ├── cypher_generator.py    # Auto Cypher生成器
│   │   └── startup.py             # 启动处理器（枚举注册、Schema同步）
│   └── common/                    # 公共模块
│       ├── exceptions.py          # 统一异常定义
│       ├── response.py            # 统一响应格式
│       └── logging.py             # 日志配置
├── tests/                         # 测试目录
├── alembic/                       # 数据库迁移
└── pyproject.toml                 # 项目配置
```

### 3.2 服务模块划分（SysML组合图）

```mermaid
graph TB
    subgraph System["心理分析系统"]
        direction TB

        subgraph P0_Services["P0 核心服务"]
            direction LR

            subgraph SVC1["模型管理服务"]
                SVC1_1["模型提供商管理"]
                SVC1_2["模型配置管理"]
                SVC1_3["模型调度器"]
                SVC1_4["性能监控"]
            end

            subgraph SVC2["提示词服务"]
                SVC2_1["模板CRUD"]
                SVC2_2["版本管理"]
                SVC2_3["模板渲染"]
                SVC2_4["本体/知识集成"]
                SVC2_5["提示词验证"]
            end

            subgraph SVC3["元本体服务"]
                SVC3_1["本体定义管理"]
                SVC3_2["属性建模"]
                SVC3_3["关系类型管理"]
                SVC3_4["本体验证器"]
                SVC3_5["版本管理"]
                SVC3_6["可视化建模支持"]
            end

            subgraph SVC4["知识图谱服务"]
                SVC4_1["知识实例管理"]
                SVC4_2["图可视化数据"]
                SVC4_3["知识导入导出"]
            end

            subgraph SVC5["RAG查询服务"]
                SVC5_1["Function Calling引擎"]
                SVC5_2["Auto Cypher生成器"]
                SVC5_3["Fallback控制器"]
                SVC5_4["查询结果格式化"]
            end
        end

        subgraph P1_Services["P1/P2 扩展服务（预留）"]
            direction LR
            SVC6["通用分析引擎"]
            SVC7["场景模板服务"]
            SVC8["报告生成服务"]
            SVC9["证据链服务"]
            SVC10["多模态处理服务"]
        end
    end

    SVC2 -->|加载模板| SVC1
    SVC2 -->|引用本体| SVC3
    SVC4 -->|遵循Schema| SVC3
    SVC4 -->|委托查询| SVC5
    SVC5 -->|读取Schema| SVC3
    SVC5 -->|调用模型| SVC1
    SVC5 -->|执行查询| SVC4
```

### 3.3 各服务能力描述与边界

#### 3.3.1 模型管理服务（P0-1）

| 项目 | 说明 |
|------|------|
| **对应PRD** | FR-3.7 模型管理与调度 |
| **核心能力** | 多模型提供商管理、模型配置CRUD、智能调度策略、调用性能监控 |
| **服务边界** | 只负责模型的注册/配置/调度/监控，不负责具体的业务分析逻辑 |
| **对外接口** | 提供统一的`invoke(model_id, prompt, params)`调用接口 |
| **依赖** | PostgreSQL（配置存储）、外部LLM API |
| **被依赖** | 提示词服务（测试调用）、RAG查询服务（模型调用）、分析引擎（P1） |

**能力清单**：
- 模型提供商注册与管理（API Key、Endpoint、认证方式）
- 模型配置管理（温度、最大Token、超时时间等）
- 模型调度策略（基于优先级的模型选择，配置默认模型和备用模型）
- 调用日志与性能监控（成功率、延迟、Token消耗）
- 模型连通性测试（手动触发，验证API Key和Endpoint可用性）
- **逻辑完整性校验**：删除提供商前检查是否有关联的模型配置，防止产生孤儿配置

#### 3.3.2 提示词服务（P0-2）

| 项目 | 说明 |
|------|------|
| **对应PRD** | FR-3.2 提示词管理系统 |
| **核心能力** | 提示词模板CRUD、版本管理、变量注入、本体/知识集成 |
| **服务边界** | 只负责提示词的管理和渲染，不负责模型调用和分析执行 |
| **对外接口** | 提供`render(template_id, variables)`渲染接口 |
| **依赖** | PostgreSQL（模板存储）、元本体服务（本体引用）、知识图谱服务（知识检索） |
| **被依赖** | RAG查询服务（提示词加载）、分析引擎（P1） |

**能力清单**：
- 提示词模板CRUD（创建、编辑、删除、查询、复制）
- 分类与标签管理（支持3级分类、多标签）
- 版本管理（草稿/测试/生产状态流转、版本对比、回滚）
- 模板渲染（变量占位符替换，支持本体字段引用、知识检索结果注入）
- 提示词验证与测试（选择模型、输入测试数据、执行LLM调用、查看输出结果、统计Token消耗/响应时间/成本）
- 结构化校验（变量引用完整性检查、本体字段引用有效性检查）
- 导入导出（JSON格式）
- **逻辑完整性校验**：删除分类前检查是否有关联模板，防止产生孤儿模板（弥补PG无外键约束）

#### 3.3.3 元本体服务（P0-3）

| 项目 | 说明 |
|------|------|
| **对应PRD** | FR-3.4 元本体体系 |
| **核心能力** | 元本体框架管理、本体定义CRUD、属性建模、关系类型管理、本体验证、**AI辅助建模** |
| **服务边界** | 只负责Schema层（本体定义），不负责Data层（知识实例） |
| **对外接口** | 提供`get_schema(ontology_id)`获取本体定义接口、`ai_suggest(description)`AI建模建议接口 |
| **依赖** | Neo4j（本体存储）、Domain层Level 0元模型（代码定义）、提示词服务（AI建模模板）、模型管理服务（LLM调用） |
| **被依赖** | 知识图谱服务（Schema约束）、提示词服务（本体引用）、分析引擎（P1） |

**能力清单**：
- 本体定义CRUD（基于Level 1业务元本体类型：Entity、Event、State、Observable、Rule、ModelConcept）
- 属性建模（14种数据类型、必填/选填、默认值、验证规则）
- 关系类型管理（29种预定义关系 + 用户自定义扩展）
- 本体分类树管理（按类型分类、支持搜索过滤）
- 本体关系图数据生成（供前端G6渲染）
- 本体版本管理（快照、对比、回滚）
- 孤立本体检查（检测无关系连接的节点）
- 本体验证（属性约束、关系约束、一致性检查）
- **可视化建模支持**：提供前端低代码建模所需的全部API能力——拖拽创建本体节点、可视化连线建立关系、组合关系自动生成属性（PART_OF/CONTAINS拖拽时自动生成子对象引用属性，支持1:1和1:N基数选择）、布局位置持久化（参考Neo4j Bloom交互风格，前端基于G6实现）
- **AI辅助建模**（P0核心）：专家输入自然语言描述（如"创伤后应激障碍的心理特征"），系统基于提示词模板调用LLM，自动建议本体结构（实体类型、属性、关系），专家在可视化画布上审核确认后落库。遵循"AI生成 → 人工确认 → 落库"模式
- **启动初始化**：系统启动时通过StartupHandler将Python枚举（29种预定义关系类型）自动注册到Neo4j，确保多实例部署一致性
- **逻辑完整性校验**：删除本体定义前检查是否有关联的知识实例，防止Schema-Data不一致

#### 3.3.4 知识图谱服务（P0-4）

| 项目 | 说明 |
|------|------|
| **对应PRD** | FR-3.6 知识图谱与语义查询 |
| **核心能力** | 知识自动化提取（P0核心）、知识实例CRUD、图可视化数据、知识导入导出、语义查询（委托RAGQueryService） |
| **服务边界** | 负责Data层（知识实例）管理和查询入口，必须遵循元本体服务定义的Schema |
| **对外接口** | 提供`extract(document, ontology_id)`、`query(cypher)`、`get_graph_data(filters)`和`smart_query(nl_query)`接口 |
| **依赖** | Neo4j（知识存储）、元本体服务（Schema约束）、提示词服务（提取模板）、模型管理服务（LLM调用）、RAG查询服务（智能查询委托） |
| **被依赖** | 提示词服务（知识注入）、分析引擎（P1） |

**能力清单**：
- **知识自动化提取**（P0核心：基于本体Schema + 提示词模板，通过LLM从文档中提取实体和关系）
- 知识实例CRUD（基于本体定义创建节点和关系）
- 图可视化数据接口（节点/边数据，供前端G6渲染）
- 知识导入（JSON/CSV批量导入，Schema校验）
- 知识导出（JSON/CSV格式）
- Cypher查询执行（直接执行用户编写的Cypher）
- 知识版本管理（与本体版本独立管理）

#### 3.3.5 RAG查询服务（P0-4，内部服务）

| 项目 | 说明 |
|------|------|
| **对应PRD** | FR-3.6.3 智能查询生成、FR-3.6.5 知识图谱参与分析（RAG机制） |
| **核心能力** | 基于本体Schema构建Function Calling工具集、Auto Cypher生成、Fallback控制、结果格式化 |
| **服务边界** | **内部服务**，不对外暴露API。只负责自然语言到图查询的转换和执行，不负责知识的增删改 |
| **对内接口** | 提供`smart_query(natural_language_query)`供KnowledgeGraphService和AnalysisService调用 |
| **依赖** | 提示词服务（加载RAG提示词模板）、元本体服务（Schema读取，构建Function工具签名）、模型管理服务（LLM调用）、知识图谱服务（Cypher执行） |
| **被依赖** | 知识图谱服务（委托智能查询）、分析引擎（P1，知识检索） |

**能力清单**：
- Function Calling引擎（预定义查询工具集、函数签名管理）
- Auto Cypher生成器（LLM驱动的动态Cypher生成）
- Fallback控制器（6种降级场景检测，详见下方决策树）
- 查询结果格式化（统一输出格式，供提示词注入使用）
- 查询日志与审计（记录查询意图、执行路径、结果）

**Fallback决策树（6种降级场景）**：

基于技术调研报告Method 5 Round 4验证结果（B组降级识别率94.4%）：

| 场景编号 | 降级场景 | 触发条件 | 处理策略 |
|---------|---------|---------|---------|
| FB-1 | API超时 | LLM响应超过`timeout_seconds`配置 | 切换备用模型重试1次，仍失败则触发Auto Cypher |
| FB-2 | API错误 | LLM返回HTTP 5xx或网络异常 | 故障转移到备用模型，仍失败则触发Auto Cypher |
| FB-3 | API限流 | LLM返回HTTP 429 | 等待`retry_after`后重试，超过3次则触发Auto Cypher |
| FB-4 | 功能限制 | LLM拒绝回答（安全策略/能力边界） | 直接触发Auto Cypher |
| FB-5 | 空结果 | Function Calling执行成功但返回空数据集 | 触发Auto Cypher尝试更宽泛的查询 |
| FB-6 | 不完整回答 | LLM返回文本而非function_call（未正确识别意图） | 触发Auto Cypher |

```mermaid
flowchart TD
    Start["接收自然语言查询"] --> FC["Function Calling"]
    FC --> Check{"响应检查"}
    Check -->|"成功 + 有结果"| Success["返回结果"]
    Check -->|"FB-1: 超时"| Retry["切换备用模型重试"]
    Check -->|"FB-2: API错误"| Retry
    Check -->|"FB-3: 限流"| Wait["等待后重试(max 3次)"]
    Check -->|"FB-4: 功能限制"| AutoCypher["Auto Cypher Fallback"]
    Check -->|"FB-5: 空结果"| AutoCypher
    Check -->|"FB-6: 不完整回答"| AutoCypher
    Retry -->|"仍失败"| AutoCypher
    Wait -->|"仍限流"| AutoCypher
    Retry -->|"成功"| Success
    Wait -->|"成功"| FC
    AutoCypher --> CypherCheck{"Cypher执行检查"}
    CypherCheck -->|"成功"| Success
    CypherCheck -->|"失败"| Error["返回错误信息"]
```

> **提示词工程原则**（来自技术调研报告）：Function Calling的边界识别依赖精确的提示词设计——让模型基于函数签名判断能力边界，强调"不确定时宁可拒绝也不要猜测"。

### 3.4 服务间依赖关系

```mermaid
graph LR
    subgraph P0服务
        ModelSvc["模型管理服务<br/>(P0-1)"]
        PromptSvc["提示词服务<br/>(P0-2)"]
        OntologySvc["元本体服务<br/>(P0-3)"]
        KGSvc["知识图谱服务<br/>(P0-4)"]
        RAGSvc["RAG查询服务<br/>(P0-4, 内部服务)"]
    end

    subgraph P1扩展服务
        AnalysisSvc["通用分析引擎<br/>(P1-2)"]
        SceneSvc["场景模板服务<br/>(P1-1)"]
        ReportSvc["报告生成服务<br/>(P1-3)"]
    end

    subgraph 数据层
        Neo4j[(Neo4j)]
        PG[(PostgreSQL)]
    end

    PromptSvc -->|测试调用| ModelSvc
    PromptSvc -->|引用本体定义| OntologySvc
    OntologySvc -->|AI建模模板| PromptSvc
    OntologySvc -->|AI建模调用LLM| ModelSvc
    KGSvc -->|遵循Schema| OntologySvc
    KGSvc -->|委托智能查询| RAGSvc
    KGSvc -->|加载提取模板| PromptSvc
    KGSvc -->|知识提取调用LLM| ModelSvc
    RAGSvc -->|加载提示词模板| PromptSvc
    RAGSvc -->|读取Schema| OntologySvc
    RAGSvc -->|调用LLM| ModelSvc
    RAGSvc -->|执行Cypher| KGSvc

    AnalysisSvc -.->|调用模型| ModelSvc
    AnalysisSvc -.->|加载提示词| PromptSvc
    AnalysisSvc -.->|检索知识| RAGSvc
    AnalysisSvc -.->|绑定场景| SceneSvc
    ReportSvc -.->|获取分析结果| AnalysisSvc

    OntologySvc --> Neo4j
    KGSvc --> Neo4j
    ModelSvc --> PG
    PromptSvc --> PG
```

**依赖原则**：
- P0服务之间通过Python模块内部调用（同进程），无网络开销
- P0服务对数据层的依赖通过Repository模式抽象，便于后续替换
- P1扩展服务（虚线）预留接口定义，P0阶段不实现
- **RAGQueryService为内部服务**：不对外暴露API，由KnowledgeGraphService委托调用，P1阶段由AnalysisService调用
- **严禁循环依赖**：RAGSvc与KGSvc之间存在双向调用（KGSvc委托查询→RAGSvc，RAGSvc执行Cypher→KGSvc），通过接口分离解耦——RAGSvc仅调用KGSvc的`execute_cypher()`方法，KGSvc仅调用RAGSvc的`smart_query()`方法，职责边界清晰
- **PromptSvc不依赖RAGSvc**：RAGSvc依赖PromptSvc加载提示词模板（Function Calling提示词、Cypher生成提示词），但PromptSvc不反向依赖RAGSvc，无循环风险
- **OntologySvc与PromptSvc双向依赖处理**：OntologySvc调用PromptSvc加载AI建模模板，PromptSvc引用OntologySvc读取本体定义。通过参数传递解耦——OntologySvc调用`render()`时将`existing_schema`作为变量传入，PromptSvc无需回调OntologySvc，运行时无循环调用

**P0服务依赖矩阵**（→ 表示依赖方向，R 表示只读依赖）：

| 服务 | ModelSvc | PromptSvc | OntologySvc | KGSvc | RAGSvc |
|------|----------|-----------|-------------|-------|--------|
| ModelSvc | - | | | | |
| PromptSvc | →(测试调用) | - | →R(本体引用) | | |
| OntologySvc | →(AI建模) | →(建模模板) | - | | |
| KGSvc | →(知识提取) | →(提取模板) | →(Schema约束) | - | →(委托查询) |
| RAGSvc | →(LLM调用) | →R(加载模板) | →R(Schema读取) | →(Cypher执行) | - |

---

## 4. 前端架构设计

### 4.1 前端分层架构

```mermaid
graph TD
    subgraph 视图层["视图层 (React Components)"]
        direction TB
        Pages["页面组件<br/>Ontology/KG/Prompt/Model"]
        Widgets["业务组件<br/>OntologyTree/GraphCanvas/Editor"]
        UI["基础UI组件<br/>Ant Design 5.x"]
    end

    subgraph 状态层["状态管理层 (Zustand)"]
        direction TB
        Store_Ontology["ontologyStore"]
        Store_KG["knowledgeStore"]
        Store_Prompt["promptStore"]
        Store_Model["modelStore"]
        Store_Global["globalStore<br/>(用户/主题/通知)"]
    end

    subgraph 服务层["数据服务层"]
        direction TB
        API_Client["API Client<br/>(Axios封装)"]
        WS_Client["WebSocket Client<br/>(P1预留)"]
    end

    视图层 --> 状态层
    状态层 --> 服务层
    服务层 -->|RESTful| Backend["后端API"]
```

**前端工程目录结构**：

```
frontend/
├── src/
│   ├── App.tsx                    # 应用入口
│   ├── routes.tsx                 # 路由配置
│   ├── pages/                     # 页面组件
│   │   ├── ontology/              # 元本体管理
│   │   │   ├── OntologyList.tsx
│   │   │   ├── OntologyEdit.tsx
│   │   │   └── OntologyGraph.tsx
│   │   ├── knowledge/             # 知识图谱
│   │   │   ├── KnowledgeCanvas.tsx
│   │   │   └── KnowledgeImport.tsx
│   │   ├── prompt/                # 提示词管理
│   │   │   ├── PromptList.tsx
│   │   │   ├── PromptEdit.tsx
│   │   │   └── PromptTest.tsx
│   │   └── model/                 # 模型管理
│   │       ├── ModelList.tsx
│   │       ├── ModelConfig.tsx
│   │       └── ModelMonitor.tsx
│   ├── components/                # 业务组件
│   │   ├── OntologyTree/          # 本体分类树
│   │   ├── GraphCanvas/           # G6图画布
│   │   ├── PromptEditor/          # 提示词编辑器
│   │   └── CypherEditor/          # Cypher编辑器
│   ├── stores/                    # Zustand状态
│   │   ├── ontologyStore.ts
│   │   ├── knowledgeStore.ts
│   │   ├── promptStore.ts
│   │   └── modelStore.ts
│   ├── services/                  # API服务
│   │   ├── apiClient.ts           # Axios封装
│   │   ├── ontologyApi.ts
│   │   ├── knowledgeApi.ts
│   │   ├── promptApi.ts
│   │   └── modelApi.ts
│   ├── hooks/                     # 自定义Hooks
│   ├── utils/                     # 工具函数
│   └── types/                     # TypeScript类型
├── public/
└── package.json
```

### 4.2 模块划分与路由设计

**布局方案**：左侧导航（240px，深色主题 #001529）+ 主工作区（自适应宽度，浅色背景 #fff）

**路由配置**：

| 路由 | 页面 | 模块 | 阶段 |
|------|------|------|------|
| `/admin/ontology/list` | 本体列表（默认） | 元本体管理 | P0 |
| `/admin/ontology/edit/:id` | 本体编辑 | 元本体管理 | P0 |
| `/admin/ontology/graph` | 本体关系图 | 元本体管理 | P0 |
| `/admin/knowledge/canvas` | 知识图谱画布（默认） | 知识图谱 | P0 |
| `/admin/knowledge/import` | 知识导入 | 知识图谱 | P0 |
| `/admin/prompts/list` | 提示词列表（默认） | 提示词管理 | P0 |
| `/admin/prompts/edit/:id` | 提示词编辑 | 提示词管理 | P0 |
| `/admin/prompts/test` | 提示词测试 | 提示词管理 | P0 |
| `/admin/models/list` | 模型列表（默认） | 模型管理 | P0 |
| `/admin/models/config/:id` | 模型配置 | 模型管理 | P0 |
| `/admin/models/monitor` | 性能监控 | 模型管理 | P0 |
| `/admin/analysis/*` | 场景分析 | 分析引擎 | P1预留 |
| `/admin/reports/*` | 报告管理 | 报告生成 | P1预留 |

### 4.3 状态管理策略

采用 **Zustand** 作为状态管理方案（轻量、TypeScript友好、无样板代码）：

| Store | 职责 | 核心状态 |
|-------|------|---------|
| `ontologyStore` | 元本体数据管理 | 本体列表、当前编辑本体、分类树、关系图数据 |
| `knowledgeStore` | 知识图谱数据管理 | 图画布数据（节点/边）、选中节点、布局配置 |
| `promptStore` | 提示词数据管理 | 模板列表、当前编辑模板、版本历史、测试结果 |
| `modelStore` | 模型配置管理 | 模型列表、提供商配置、监控数据 |
| `globalStore` | 全局状态 | 用户信息、主题配置、通知消息、加载状态 |

**状态管理原则**：
- 服务端数据通过API获取后缓存到Store，避免重复请求
- 表单编辑状态保持在组件本地State，提交后同步到Store
- 图画布状态（节点位置、缩放等）持久化到localStorage

### 4.4 图可视化方案

采用 **G6 (AntV)** 作为图可视化引擎，参考Neo4j Bloom的交互模式：

| 场景 | 技术方案 | 性能预算 |
|------|---------|---------|
| 本体关系图 | G6 力导向布局 | 节点数 < 500，渲染 < 1s |
| 知识图谱画布 | G6 自定义布局 | 节点数 < 2000，渲染 < 2s |
| 推理链路图（P1） | G6 有向无环图布局 | 节点数 < 100，渲染 < 500ms |

**G6配置策略**：
- 节点样式：圆角矩形，按本体类型着色（Entity蓝色、Event橙色、State绿色等）
- 边样式：箭头连线，显示关系类型标签
- 交互：拖拽节点、滚轮缩放、框选、点击查看详情（右侧抽屉）
- 布局：默认力导向布局，支持手动拖拽调整，布局位置可保存
- 性能优化：虚拟滚动、节点聚合（节点数 > 500时自动聚合）

---

## 5. 数据模型设计（ER图）

### 5.1 PostgreSQL关系模型

PostgreSQL负责存储系统配置数据、提示词模板、模型配置等结构化业务数据。

> **重要说明**: 以下ER图中的关系线仅表示**逻辑关联关系**，数据库层面**严禁使用外键约束**。数据完整性通过应用层代码保证，支持灵活的连表查询但不创建FK约束。

#### 5.1.1 模型管理数据模型

```mermaid
erDiagram
    MODEL_PROVIDER {
        uuid id PK
        string name
        string api_type
        string base_url
        string api_key_encrypted
        boolean is_active
        timestamp created_at
        timestamp updated_at
    }

    MODEL_CONFIG {
        uuid id PK
        uuid provider_id
        string model_name
        string display_name
        string model_type
        float temperature
        int max_tokens
        int timeout_seconds
        json extra_params
        boolean is_default
        timestamp created_at
        timestamp updated_at
    }

    MODEL_CALL_LOG {
        uuid id PK
        uuid model_config_id
        string call_type
        int input_tokens
        int output_tokens
        float latency_ms
        string status
        text error_message
        timestamp created_at
    }

    MODEL_PROVIDER ||--o{ MODEL_CONFIG : "逻辑关联"
    MODEL_CONFIG ||--o{ MODEL_CALL_LOG : "逻辑关联"
```

**MODEL_PROVIDER 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，模型提供商唯一标识 |
| name | VARCHAR(100) | NOT NULL, UNIQUE | 提供商名称（如：OpenAI, Anthropic, Gemini） |
| api_type | VARCHAR(50) | NOT NULL | API类型（openai/anthropic/google/custom） |
| base_url | VARCHAR(500) | NOT NULL | API基础URL地址 |
| api_key_encrypted | TEXT | NOT NULL | 加密后的API密钥（AES-256加密） |
| is_active | BOOLEAN | NOT NULL, DEFAULT true | 是否启用该提供商 |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 最后更新时间 |

**MODEL_CONFIG 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，模型配置唯一标识 |
| provider_id | UUID | NOT NULL | 关联的提供商ID（逻辑关联MODEL_PROVIDER.id） |
| model_name | VARCHAR(100) | NOT NULL | 模型名称（如：gpt-4o, claude-3-5-sonnet） |
| display_name | VARCHAR(200) | NOT NULL | 显示名称（用户友好的名称） |
| model_type | VARCHAR(50) | NOT NULL | 模型类型（llm/vlm/embedding） |
| temperature | FLOAT | DEFAULT 0.7 | 温度参数（0.0-2.0） |
| max_tokens | INTEGER | DEFAULT 4096 | 最大输出Token数 |
| timeout_seconds | INTEGER | DEFAULT 60 | 超时时间（秒） |
| extra_params | JSONB | NULL | 额外参数（top_p, frequency_penalty等） |
| is_default | BOOLEAN | DEFAULT false | 是否为该类型的默认模型 |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 最后更新时间 |

**MODEL_CALL_LOG 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，调用日志唯一标识 |
| model_config_id | UUID | NOT NULL | 关联的模型配置ID（逻辑关联MODEL_CONFIG.id） |
| call_type | VARCHAR(50) | NOT NULL | 调用类型（analysis/ontology_build/knowledge_build） |
| input_tokens | INTEGER | NOT NULL | 输入Token数 |
| output_tokens | INTEGER | NOT NULL | 输出Token数 |
| latency_ms | FLOAT | NOT NULL | 响应延迟（毫秒） |
| status | VARCHAR(20) | NOT NULL | 调用状态（success/error/timeout） |
| error_message | TEXT | NULL | 错误信息（仅status=error时） |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 调用时间 |

#### 5.1.2 提示词管理数据模型

```mermaid
erDiagram
    PROMPT_CATEGORY {
        uuid id PK
        uuid parent_id
        string name
        int sort_order
        timestamp created_at
    }

    PROMPT_TEMPLATE {
        uuid id PK
        uuid category_id
        string name
        string description
        text content
        json variables
        string status
        int current_version
        timestamp created_at
        timestamp updated_at
    }

    PROMPT_VERSION {
        uuid id PK
        uuid template_id
        int version_number
        text content
        json variables
        string change_note
        string created_by
        timestamp created_at
    }

    PROMPT_TAG {
        uuid id PK
        string name
    }

    PROMPT_TEMPLATE_TAG {
        uuid template_id
        uuid tag_id
    }

    PROMPT_CATEGORY ||--o{ PROMPT_TEMPLATE : "逻辑关联"
    PROMPT_CATEGORY ||--o{ PROMPT_CATEGORY : "自引用parent_id"
    PROMPT_TEMPLATE ||--o{ PROMPT_VERSION : "逻辑关联"
    PROMPT_TEMPLATE ||--o{ PROMPT_TEMPLATE_TAG : "逻辑关联"
    PROMPT_TAG ||--o{ PROMPT_TEMPLATE_TAG : "逻辑关联"
```

**PROMPT_CATEGORY 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，分类唯一标识 |
| parent_id | UUID | NULL | 父分类ID（逻辑关联PROMPT_CATEGORY.id，支持多级分类树） |
| name | VARCHAR(100) | NOT NULL | 分类名称 |
| sort_order | INTEGER | DEFAULT 0 | 排序顺序（同级分类按此字段升序排列） |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |

**PROMPT_TEMPLATE 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，模板唯一标识 |
| category_id | UUID | NOT NULL | 关联的分类ID（逻辑关联PROMPT_CATEGORY.id） |
| name | VARCHAR(200) | NOT NULL | 模板名称 |
| description | TEXT | NULL | 模板描述（用途、适用场景等） |
| content | TEXT | NOT NULL | 提示词内容（支持变量占位符{{var_name}}） |
| variables | JSONB | NULL | 变量定义（变量名、类型、默认值、描述） |
| status | VARCHAR(20) | NOT NULL, DEFAULT 'draft' | 状态（draft/testing/production） |
| current_version | INTEGER | NOT NULL, DEFAULT 1 | 当前版本号 |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 最后更新时间 |

**PROMPT_VERSION 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，版本唯一标识 |
| template_id | UUID | NOT NULL | 关联的模板ID（逻辑关联PROMPT_TEMPLATE.id） |
| version_number | INTEGER | NOT NULL | 版本号（从1开始递增） |
| content | TEXT | NOT NULL | 该版本的提示词内容 |
| variables | JSONB | NULL | 该版本的变量定义 |
| change_note | TEXT | NULL | 变更说明（记录本次修改的原因和内容） |
| created_by | VARCHAR(100) | NOT NULL | 创建人（用户ID或用户名） |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |

**PROMPT_TAG 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| id | UUID | PK, NOT NULL | 主键，标签唯一标识 |
| name | VARCHAR(50) | NOT NULL, UNIQUE | 标签名称（如：心理分析、审讯场景、RAG） |

**PROMPT_TEMPLATE_TAG 表字段说明**：

| 字段名 | 数据类型 | 约束 | 说明 |
|-------|---------|------|------|
| template_id | UUID | PK, NOT NULL | 模板ID（逻辑关联PROMPT_TEMPLATE.id） |
| tag_id | UUID | PK, NOT NULL | 标签ID（逻辑关联PROMPT_TAG.id） |

**说明**：PROMPT_TEMPLATE_TAG为多对多关联表，联合主键(template_id, tag_id)保证唯一性。

### 5.2 Neo4j图模型

Neo4j负责存储元本体定义（Schema层）和知识图谱实例（Data层），采用三层架构。

**Level 0 元模型层（代码定义，非Neo4j存储）**：

| 类 | 说明 | 实现方式 |
|----|------|---------|
| `Thing` | 所有本体的基类 | Python抽象类 |
| `RelationshipType` | 关系类型定义 | Python数据类 |
| `RelationshipTypeEnum` | 29种预定义关系枚举 | Python Enum |

**Level 1 业务元本体层 + Level 2 心理领域层（Neo4j存储）**：

```mermaid
graph TB
    subgraph Schema层["Schema层（元本体定义）"]
        OntologyDef["(:OntologyDefinition)<br/>uid, name, type, description<br/>category, version, status<br/>version_tag"]
        AttrDef["(:AttributeDefinition)<br/>uid, name, data_type<br/>required, default_value<br/>validation_rules"]
        RelTypeDef["(:RelationshipTypeDefinition)<br/>uid, name, inverse_name<br/>source_types, target_types<br/>cardinality"]
    end

    subgraph Data层["Data层（知识实例）"]
        KnowledgeNode["(:KnowledgeNode)<br/>uid, ontology_type<br/>properties: JSON<br/>version_tag, created_at, updated_at"]
        KnowledgeRelNode["(:KnowledgeRelation)<br/>uid, rel_type<br/>properties: JSON<br/>source_uid, target_uid<br/>version_tag, created_at"]
    end

    OntologyDef -->|HAS_ATTRIBUTE| AttrDef
    OntologyDef -->|HAS_RELATIONSHIP_TYPE| RelTypeDef
    KnowledgeNode -->|INSTANCE_OF| OntologyDef
    KnowledgeNode -->|HAS_RELATION| KnowledgeRelNode
    KnowledgeRelNode -->|POINTS_TO| KnowledgeNode
    KnowledgeRelNode -->|DEFINED_BY| RelTypeDef
```

> **关键设计决策 - Relationship节点化**：
> 知识关系采用**中间节点模式**（`KnowledgeRelation`节点）而非Neo4j原生边。原因：元本体需求文档中Relationship继承自Thing（Level 1），需要支持独立ID、属性验证、版本追踪和证据溯源。原生边无法承载这些Thing特性。查询模式为：`(源节点)-[:HAS_RELATION]->(关系节点)-[:POINTS_TO]->(目标节点)`。

**版本管理策略**：

Neo4j不原生支持版本快照，采用`version_tag`属性标记方案：

| 属性 | 说明 | 示例 |
|------|------|------|
| `version_tag` | 版本标识符 | `"v1.0"`, `"v1.1"` |
| `status` | 版本状态 | `"draft"` / `"published"` / `"archived"` |

- **创建快照**：复制当前版本所有节点，赋予新`version_tag`，原版本`status`标记为`archived`
- **版本回滚**：将目标版本的`status`设为`published`，当前版本设为`archived`
- **查询约定**：默认查询`status = "published"`的数据，历史版本通过`version_tag`过滤

### 5.3 存储策略与数据流

**双库分工原则**：

| 数据类型 | 存储位置 | 理由 |
|---------|---------|------|
| 模型提供商/配置 | PostgreSQL | 结构化配置，CRUD为主 |
| 模型调用日志 | PostgreSQL | 时序数据，聚合查询 |
| 提示词模板/版本 | PostgreSQL | 文本内容，版本管理 |
| 元本体定义（Schema） | Neo4j | 图结构，关系查询 |
| 知识实例（Data） | Neo4j | 图遍历，语义查询 |
| 向量嵌入（P2） | Milvus | 相似度检索 |
| 用户/权限（P3） | PostgreSQL | 关系型，事务性 |

**跨库数据一致性保证**：

由于系统采用双库策略（PostgreSQL + Neo4j），需要在应用层保证跨库数据一致性：

| 场景 | 一致性策略 | 说明 |
|------|-----------|------|
| 提示词引用本体字段 | **读时校验** | 渲染提示词时实时查询Neo4j验证本体字段是否存在 |
| 本体版本变更 | **同步更新** | Service层先更新Neo4j本体，成功后更新PG中关联的版本记录；失败则回滚 |
| 删除操作 | **前置检查** | Service层执行`pre_delete_check`，检查跨库关联后再执行删除 |
| P1扩展预留 | **事件通知** | 预留事件接口，未来可引入消息队列实现异步通知（如本体变更通知提示词服务刷新缓存） |

```mermaid
flowchart LR
    subgraph 写入流
        FE_Write["前端表单"] --> API_Write["API层"]
        API_Write --> SVC_Write["Service层"]
        SVC_Write -->|配置数据| PG_Write[(PostgreSQL)]
        SVC_Write -->|本体/知识| Neo4j_Write[(Neo4j)]
    end

    subgraph 查询流
        FE_Query["前端查询"] --> API_Query["API层"]
        API_Query --> SVC_Query["Service层"]
        SVC_Query -->|配置查询| PG_Read[(PostgreSQL)]
        SVC_Query -->|图查询| Neo4j_Read[(Neo4j)]
    end

    subgraph RAG流
        NLQ["自然语言查询"] --> FC["Function Calling"]
        FC -->|成功| Neo4j_FC[(Neo4j)]
        FC -->|失败| Cypher["Auto Cypher"]
        Cypher --> Neo4j_Cypher[(Neo4j)]
    end
```

---

## 6. 接口协议设计

### 6.1 API总览

所有API遵循RESTful规范，基础路径为 `/api/v1/`。

| 服务 | 路径前缀 | 核心端点数 | 阶段 |
|------|---------|-----------|------|
| 模型管理 | `/api/v1/models` | 8 | P0 |
| 提示词管理 | `/api/v1/prompts` | 10 | P0 |
| 元本体管理 | `/api/v1/ontologies` | 13 | P0 |
| 知识图谱 | `/api/v1/kg` | 12 | P0 |
| 分析引擎 | `/api/v1/analysis` | - | P1预留 |
| 报告生成 | `/api/v1/reports` | - | P1预留 |

> **说明**：RAG查询能力（自然语言查询、Cypher查询）作为知识图谱模块的子功能，API端点归入`/api/v1/kg`路径下，不单独暴露API路由。RAGQueryService作为内部服务，由KnowledgeGraphService调用。

### 6.2 统一响应格式

**成功响应**：

```json
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": "2026-02-08T12:00:00Z"
}
```

**错误响应**：

```json
{
  "code": 400,
  "message": "参数校验失败",
  "data": null,
  "errors": [
    {"field": "name", "message": "名称不能为空"}
  ],
  "timestamp": "2026-02-08T12:00:00Z"
}
```

**SSE流式响应格式（RAG长耗时查询专用）**：

RAG查询（`/api/v1/kg/smart-query`）响应时间可达15.9s-45.9s（技术调研报告数据），标准RESTful请求易触发Nginx/浏览器超时。采用**SSE（Server-Sent Events）**协议：

```
Content-Type: text/event-stream

event: progress
data: {"phase": "function_calling", "progress": 20, "message": "正在解析查询意图..."}

event: progress
data: {"phase": "function_calling", "progress": 50, "message": "正在执行图查询..."}

event: fallback
data: {"phase": "auto_cypher", "progress": 60, "reason": "function_limitation", "message": "触发Fallback，正在生成Cypher..."}

event: progress
data: {"phase": "auto_cypher", "progress": 80, "message": "正在执行Cypher查询..."}

event: result
data: {"query_path": "fallback_cypher", "cypher": "MATCH (n)...", "results": [...], "total_time_ms": 23500}

event: done
data: {"status": "success"}
```

SSE事件类型：

| 事件类型 | 说明 | 触发时机 |
|---------|------|---------|
| `progress` | 进度更新 | 每个处理阶段开始时 |
| `fallback` | 降级通知 | 触发Fallback时 |
| `result` | 查询结果 | 查询完成时 |
| `error` | 错误信息 | 查询失败时 |
| `done` | 流结束 | 所有处理完成时 |

> **前端适配**：使用`EventSource` API或`fetch` + `ReadableStream`接收SSE事件，在UI中展示实时进度条和阶段状态。

**状态码规范**：

| 状态码 | 含义 | 使用场景 |
|--------|------|---------|
| 200 | 成功 | GET/PUT/DELETE成功 |
| 201 | 创建成功 | POST创建资源成功 |
| 400 | 参数错误 | 请求参数校验失败 |
| 404 | 资源不存在 | 查询的资源不存在 |
| 422 | 业务校验失败 | 业务规则校验不通过 |
| 500 | 服务器错误 | 未预期的内部错误 |
| 503 | 服务不可用 | LLM API不可用等 |

### 6.3 各服务API定义

#### 6.3.1 模型管理API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/models/providers` | 获取模型提供商列表 |
| POST | `/api/v1/models/providers` | 创建模型提供商 |
| PUT | `/api/v1/models/providers/{id}` | 更新模型提供商 |
| DELETE | `/api/v1/models/providers/{id}` | 删除模型提供商 |
| GET | `/api/v1/models/configs` | 获取模型配置列表 |
| POST | `/api/v1/models/configs` | 创建模型配置 |
| PUT | `/api/v1/models/configs/{id}` | 更新模型配置 |
| POST | `/api/v1/models/configs/{id}/test` | 测试模型连通性 |

#### 6.3.2 提示词管理API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/prompts/categories` | 获取分类树 |
| POST | `/api/v1/prompts/categories` | 创建分类 |
| GET | `/api/v1/prompts/templates` | 获取模板列表（支持分页、筛选） |
| POST | `/api/v1/prompts/templates` | 创建模板 |
| GET | `/api/v1/prompts/templates/{id}` | 获取模板详情 |
| PUT | `/api/v1/prompts/templates/{id}` | 更新模板 |
| DELETE | `/api/v1/prompts/templates/{id}` | 删除模板 |
| POST | `/api/v1/prompts/templates/{id}/copy` | 复制模板 |
| GET | `/api/v1/prompts/templates/{id}/versions` | 获取版本历史 |
| POST | `/api/v1/prompts/templates/{id}/test` | 测试提示词（调用LLM） |

#### 6.3.3 元本体管理API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/ontologies` | 获取本体列表（支持分类筛选） |
| POST | `/api/v1/ontologies` | 创建本体定义 |
| GET | `/api/v1/ontologies/{id}` | 获取本体详情（含属性和关系） |
| PUT | `/api/v1/ontologies/{id}` | 更新本体定义 |
| DELETE | `/api/v1/ontologies/{id}` | 删除本体定义 |
| GET | `/api/v1/ontologies/tree` | 获取本体分类树 |
| GET | `/api/v1/ontologies/graph` | 获取本体关系图数据（G6格式） |
| POST | `/api/v1/ontologies/{id}/attributes` | 添加属性定义 |
| PUT | `/api/v1/ontologies/{id}/attributes/{attrId}` | 更新属性定义 |
| POST | `/api/v1/ontologies/{id}/relationships` | 添加关系定义 |
| GET | `/api/v1/ontologies/versions` | 获取版本历史 |
| POST | `/api/v1/ontologies/versions` | 创建版本快照 |
| POST | `/api/v1/ontologies/ai-suggest` | AI辅助建模：输入自然语言描述，返回建议的本体结构（不直接落库） |

#### 6.3.4 知识图谱API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/kg/nodes` | 获取知识节点列表（分页） |
| POST | `/api/v1/kg/nodes` | 创建知识节点 |
| GET | `/api/v1/kg/nodes/{id}` | 获取节点详情 |
| PUT | `/api/v1/kg/nodes/{id}` | 更新知识节点 |
| DELETE | `/api/v1/kg/nodes/{id}` | 删除知识节点 |
| POST | `/api/v1/kg/relationships` | 创建知识关系 |
| GET | `/api/v1/kg/graph` | 获取图可视化数据（G6格式） |
| POST | `/api/v1/kg/import` | 批量导入知识（JSON/CSV） |
| POST | `/api/v1/kg/extract` | 基于本体Schema的知识自动提取（LLM驱动，返回预览数据，不直接落库） |
| POST | `/api/v1/kg/smart-query` | 自然语言智能查询（SSE流式响应，内部委托RAGQueryService） |
| POST | `/api/v1/kg/cypher` | 直接执行Cypher查询 |
| GET | `/api/v1/kg/query-tools` | 获取可用的查询工具列表（Function Calling工具集） |

> **说明**：知识提取（`extract`）是P0核心功能，由KnowledgeGraphService直接编排PromptSvc + ModelSvc完成，返回预览数据不直接落库。自然语言查询（`smart-query`）和Cypher查询（`cypher`）是查询子功能（对应PRD FR-3.6.3），内部委托RAGQueryService处理。所有端点由kg_router统一路由，RAGQueryService不对外暴露独立API。

---

## 7. 核心场景交互设计

### 7.1 用例图

#### 7.1.1 P0阶段核心用例

```mermaid
graph LR
    subgraph 角色
        Expert["心理学专家"]
        Admin["系统管理员"]
    end

    subgraph UC_Ontology["元本体管理用例"]
    direction RL
        UC_O1["UC-O1: 创建本体定义"]
        UC_O2["UC-O2: 编辑本体属性"]
        UC_O3["UC-O3: 定义本体关系"]
        UC_O4["UC-O4: 查看本体关系图"]
        UC_O5["UC-O5: 管理本体版本"]
        UC_O6["UC-O6: 检查孤立本体"]
    end

    subgraph UC_KG["知识图谱用例"]
        direction RL
        UC_K1["UC-K1: 创建知识节点"]
        UC_K2["UC-K2: 建立知识关系"]
        UC_K3["UC-K3: 浏览知识图谱"]
        UC_K4["UC-K4: 自然语言查询"]
        UC_K5["UC-K5: 导入知识数据"]
    end

    subgraph UC_Prompt["提示词管理用例"]
        direction RL
        UC_P1["UC-P1: 创建提示词模板"]
        UC_P2["UC-P2: 编辑提示词内容"]
        UC_P3["UC-P3: 测试提示词效果"]
        UC_P4["UC-P4: 管理提示词版本"]
    end

    subgraph UC_Model["模型管理用例"]
        direction RL
        UC_M1["UC-M1: 注册模型提供商"]
        UC_M2["UC-M2: 配置模型参数"]
        UC_M3["UC-M3: 测试模型连通性"]
        UC_M4["UC-M4: 查看调用监控"]
    end

    Expert --> UC_O1
    Expert --> UC_O2
    Expert --> UC_O3
    Expert --> UC_O4
    Expert --> UC_O5
    Expert --> UC_O6
    Expert --> UC_K1
    Expert --> UC_K2
    Expert --> UC_K3
    Expert --> UC_K4
    Expert --> UC_K5
    Expert --> UC_P1
    Expert --> UC_P2
    Expert --> UC_P3
    Expert --> UC_P4
    Admin --> UC_M1
    Admin --> UC_M2
    Admin --> UC_M3
    Admin --> UC_M4
```

### 7.2 核心场景序列图

#### 7.2.1 场景一：基于本体的知识自动化构建（P0核心场景，贯穿全服务链路）

此场景是P0阶段最核心的端到端场景，专家提供文本/文档，系统基于本体Schema和提示词模板，通过LLM自动提取知识并写入图谱。贯穿元本体、提示词、模型管理、知识图谱四个服务。

```mermaid
sequenceDiagram
    actor Expert as 心理学专家
    participant FE as 前端（知识图谱模块）
    participant API as API网关
    participant KG as 知识图谱服务
    participant Prompt as 提示词服务
    participant Onto as 元本体服务
    participant Model as 模型管理服务
    participant LLM as LLM API
    participant Neo4j as Neo4j

    Note over Expert,Neo4j: Phase A: 知识提取（AI生成，前端暂存）

    Expert->>FE: 上传文档/粘贴文本
    FE->>API: POST /api/v1/kg/extract
    API->>KG: extract_knowledge(document, ontology_id)

    Note over KG: Step 1: 加载本体Schema和提示词模板
    KG->>Onto: get_schema(ontology_id)
    Onto-->>KG: 返回本体定义（实体类型、属性、关系类型）
    KG->>Prompt: render(template_id="knowledge_extraction", variables={schema, document})
    Prompt-->>KG: 渲染后的知识提取提示词

    Note over KG: Step 2: LLM提取知识
    KG->>Model: invoke(model_id, rendered_prompt)
    Model->>LLM: 发送请求（文档+Schema+提取指令）
    LLM-->>Model: 返回结构化知识（JSON）
    Model-->>KG: 提取结果（实体列表+关系列表）

    KG->>KG: Schema合规性校验
    KG-->>API: 返回提取结果（未持久化）
    API-->>FE: 提取的实体和关系（预览数据）
    FE->>FE: Zustand暂存，渲染预览画布

    Note over Expert,Neo4j: Phase B: 人工确认并落库

    Expert->>FE: 审核、修改、确认提取结果
    FE->>API: POST /api/v1/kg/nodes（批量）
    API->>KG: batch_create(confirmed_entities)
    KG->>Neo4j: CREATE节点和关系
    Neo4j-->>KG: 写入成功
    KG-->>API: 创建结果
    API-->>FE: 成功响应
    FE-->>Expert: 画布更新，展示已入库知识
```

#### 7.2.2 场景二：自然语言智能查询（辅助功能，P1核心）

此场景在P0阶段作为知识图谱模块的辅助查询功能（交互设计3.2.7查询工具），P1阶段将成为分析引擎的核心能力。P0阶段用户主要使用过滤查询和Cypher查询。

```mermaid
sequenceDiagram
    actor User as 用户
    participant FE as 前端（知识图谱模块）
    participant API as API网关
    participant KG as 知识图谱服务
    participant RAG as RAG查询服务（内部）
    participant Prompt as 提示词服务
    participant Onto as 元本体服务
    participant Model as 模型管理服务
    participant LLM as LLM API
    participant Neo4j as Neo4j

    User->>FE: 输入自然语言查询
    FE->>API: POST /api/v1/kg/smart-query (SSE)
    API->>KG: smart_query(query)
    KG->>RAG: 委托智能查询

    Note over RAG: Step 1: 加载提示词模板和本体Schema
    RAG->>Prompt: render(template_id="function_calling", variables)
    Prompt-->>RAG: 渲染后的Function Calling提示词
    RAG->>Onto: get_schema() 读取本体Schema
    Onto-->>RAG: 返回本体定义（实体类型、关系类型）
    RAG->>RAG: 基于Schema生成Function签名

    Note over RAG: Step 2: Function Calling
    RAG->>Model: invoke(model_id, rendered_prompt + functions)
    Model->>LLM: 发送请求（含function签名）
    LLM-->>Model: 返回function_call或文本

    alt Function Calling成功
        Model-->>RAG: function_call结果
        RAG->>KG: 执行预定义查询函数
        KG->>Neo4j: 执行Cypher
        Neo4j-->>KG: 查询结果
        KG-->>RAG: 格式化结果
    else 触发Fallback（6种降级场景）
        Note over RAG: 检测: 超时/错误/限流/功能限制/空结果/不完整
        RAG->>Prompt: render(template_id="cypher_generation", variables)
        Prompt-->>RAG: 渲染后的Cypher生成提示词
        RAG->>Model: invoke(model_id, cypher_gen_prompt)
        Model->>LLM: 请求生成Cypher
        LLM-->>Model: 返回Cypher语句
        Model-->>RAG: Cypher语句
        RAG->>KG: execute_cypher(cypher)
        KG->>Neo4j: 执行动态Cypher
        Neo4j-->>KG: 查询结果
        KG-->>RAG: 格式化结果
    end

    RAG->>RAG: 格式化最终响应
    RAG-->>KG: 查询结果
    KG-->>API: SSE流式响应
    API-->>FE: SSE事件流（progress/result/done）
    FE-->>User: 展示查询结果（画布高亮）
```

> **场景定位**：P0阶段作为辅助查询功能，用户主要使用过滤查询和Cypher查询。P1阶段升级为分析引擎核心能力。

#### 7.2.3 场景三：AI辅助本体建模（P0核心场景，与7.2.1共同构成AI驱动闭环）

专家输入自然语言描述，系统基于提示词模板调用LLM生成本体结构建议，专家在可视化画布上审核确认后落库。与知识自动化构建（7.2.1）共同构成"先建Schema，再提取Data"的完整闭环。

```mermaid
sequenceDiagram
    actor Expert as 心理学专家
    participant FE as 前端（元本体模块）
    participant API as API网关
    participant Onto as 元本体服务
    participant Prompt as 提示词服务
    participant Model as 模型管理服务
    participant LLM as LLM API
    participant Neo4j as Neo4j

    Note over Expert,Neo4j: Phase A: AI生成建议（前端暂存）

    Expert->>FE: 输入自然语言描述（如"创伤后应激障碍的心理特征"）
    FE->>API: POST /api/v1/ontologies/ai-suggest
    API->>Onto: ai_suggest(description, context)

    Note over Onto: Step 1: 加载建模提示词模板
    Onto->>Prompt: render(template_id="ontology_modeling", variables={description, existing_schema})
    Prompt-->>Onto: 渲染后的建模提示词

    Note over Onto: Step 2: LLM生成本体建议
    Onto->>Model: invoke(model_id, rendered_prompt)
    Model->>LLM: 发送请求（描述+现有Schema+建模指令）
    LLM-->>Model: 返回建议的本体结构（JSON）
    Model-->>Onto: 建议结果（实体类型、属性、关系）

    Onto->>Onto: Level 0元模型合规性校验
    Onto-->>API: 返回建议结果（未持久化）
    API-->>FE: 建议的本体结构（预览数据）
    FE->>FE: Zustand暂存，渲染到可视化画布

    Note over Expert,Neo4j: Phase B: 人工确认并落库

    Expert->>FE: 在画布上审核、调整、确认
    FE->>API: POST /api/v1/ontologies（含属性和关系）
    API->>Onto: create_ontology(confirmed_data)
    Onto->>Onto: 完整校验（类型、属性、关系约束）
    Onto->>Neo4j: CREATE (:OntologyDefinition) + 属性 + 关系
    Neo4j-->>Onto: 创建成功
    Onto-->>API: 本体定义对象
    API-->>FE: 成功响应
    FE-->>Expert: 画布更新，展示已入库本体
```

#### 7.2.4 场景四：手动创建本体定义（元本体管理基础流程）

```mermaid
sequenceDiagram
    actor Expert as 心理学专家
    participant FE as 前端
    participant API as API网关
    participant Onto as 元本体服务
    participant Domain as Domain层
    participant Neo4j as Neo4j

    Expert->>FE: 填写本体表单
    Note over FE: 名称、类型、属性、关系
    FE->>FE: 前端表单校验

    FE->>API: POST /api/v1/ontologies
    API->>Onto: create_ontology(data)

    Onto->>Domain: 校验本体类型合法性
    Note over Domain: 检查type是否属于Level 1类型
    Domain-->>Onto: 校验通过

    Onto->>Domain: 校验属性定义
    Note over Domain: 数据类型、必填、验证规则
    Domain-->>Onto: 校验通过

    Onto->>Domain: 校验关系定义
    Note over Domain: 关系类型、目标本体、基数
    Domain-->>Onto: 校验通过

    Onto->>Neo4j: CREATE (:OntologyDefinition)
    Neo4j-->>Onto: 创建成功
    Onto->>Neo4j: CREATE (:AttributeDefinition)
    Neo4j-->>Onto: 创建成功

    Onto-->>API: 本体定义对象
    API-->>FE: 201 Created
    FE-->>Expert: 显示创建成功
```

#### 7.2.5 场景五：提示词测试（贯穿提示词 + 模型管理）

```mermaid
sequenceDiagram
    actor Expert as 心理学专家
    participant FE as 前端
    participant API as API网关
    participant Prompt as 提示词服务
    participant Model as 模型管理服务
    participant LLM as LLM API

    Expert->>FE: 选择模板并输入测试数据
    FE->>API: POST /api/v1/prompts/templates/{id}/test
    API->>Prompt: test_prompt(template_id, test_data)

    Prompt->>Prompt: 加载模板内容
    Prompt->>Prompt: 注入变量（替换占位符）
    Prompt->>Model: invoke(model_id, rendered_prompt)
    Model->>Model: 查找模型配置
    Model->>LLM: 发送请求
    LLM-->>Model: 返回生成结果
    Model->>Model: 记录调用日志

    Model-->>Prompt: LLM响应
    Prompt-->>API: 测试结果
    API-->>FE: JSON响应
    FE-->>Expert: 展示测试结果
```

### 7.3 状态转换图

#### 7.3.1 提示词模板生命周期

```mermaid
stateDiagram-v2
    [*] --> 草稿: 创建模板
    草稿 --> 草稿: 编辑内容
    草稿 --> 测试中: 提交测试
    测试中 --> 草稿: 测试不通过（修改）
    测试中 --> 已发布: 测试通过（发布）
    已发布 --> 已归档: 归档
    已发布 --> 草稿: 创建新版本
    已归档 --> 已发布: 恢复
    已归档 --> [*]: 删除
```

#### 7.3.2 RAG查询执行状态

```mermaid
stateDiagram-v2
    [*] --> 接收查询: 用户提交自然语言

    接收查询 --> FunctionCalling: 解析意图

    state FunctionCalling {
        [*] --> 匹配函数: LLM选择工具
        匹配函数 --> 执行查询: 函数匹配成功
        匹配函数 --> 触发Fallback: 功能限制/拒绝回答
        执行查询 --> 结果校验: 查询完成
        结果校验 --> 触发Fallback: 空结果/不完整
    }

    触发Fallback --> AutoCypher: 降级处理

    state AutoCypher {
        [*] --> 生成Cypher: LLM生成查询
        生成Cypher --> 执行Cypher: Cypher合法
        生成Cypher --> 查询失败: Cypher语法错误
        执行Cypher --> Cypher结果校验: 执行完成
    }

    FunctionCalling --> 返回结果: 查询成功
    AutoCypher --> 返回结果: Cypher查询成功
    AutoCypher --> 查询失败: Cypher查询失败

    返回结果 --> [*]
    查询失败 --> [*]: 返回错误信息
```

---

## 8. 部署架构设计

### 8.1 部署拓扑图

```mermaid
graph TB
    subgraph 客户端["客户端"]
        Browser["浏览器<br/>Chrome/Edge/Firefox<br/>分辨率 >= 1200px"]
    end

    subgraph 应用服务器["应用服务器（开发/测试环境）"]
        Nginx["Nginx<br/>静态资源 + 反向代理<br/>:80 / :443"]
        FE_Build["前端构建产物<br/>React SPA"]
        Backend["FastAPI应用<br/>Uvicorn :8000"]
    end

    subgraph 数据服务器["数据服务器 192.168.176.128"]
        Neo4j_Deploy["Neo4j 5.x<br/>HTTP :7474<br/>Bolt :7687"]
        PG_Deploy["PostgreSQL<br/>:5432<br/>testuser/testdb"]
        Milvus_Deploy["Milvus<br/>Attu :8000<br/>gRPC :19530"]
    end

    subgraph 外部服务["外部AI服务"]
        LLM_API["LLM API<br/>GPT-4o / Claude / Gemini"]
    end

    Browser -->|HTTPS| Nginx
    Nginx -->|静态文件| FE_Build
    Nginx -->|/api/*| Backend
    Backend -->|Bolt| Neo4j_Deploy
    Backend -->|TCP| PG_Deploy
    Backend -->|gRPC| Milvus_Deploy
    Backend -->|HTTPS| LLM_API
```

### 8.2 基础设施配置

#### 8.2.1 已部署服务（数据服务器 192.168.176.128）

| 服务 | 端口 | 连接方式 | 认证 | 状态 |
|------|------|---------|------|------|
| **Neo4j** | HTTP 7474, Bolt 7687 | `bolt://192.168.176.128:7687` | 未启用认证 | 已部署，开机自启 |
| **PostgreSQL** | 5432 | `postgresql://testuser:123456@192.168.176.128:5432/testdb` | testuser/123456 | 已部署，开机自启 |
| **Milvus** | Attu 8000, gRPC 19530 | `192.168.176.128:19530` | 未启用认证 | 已部署，开机自启 |

#### 8.2.2 P0阶段部署方案

采用**单机部署**方案，降低运维复杂度：

```
应用服务器（开发机）
├── Nginx                    # 静态资源 + 反向代理
├── frontend/dist/           # React构建产物
└── backend/
    └── uvicorn main:app     # FastAPI应用（单进程）
```

**P0部署约束**：
- 单进程部署，支持10并发
- 无需容器化，直接Python虚拟环境运行
- Nginx配置：静态资源缓存 + API反向代理
- 日志输出到文件，按天轮转

---

## 9. 测试策略与验收标准

### 9.1 测试分层策略

```mermaid
graph TB
    subgraph 测试金字塔
        E2E["端到端测试<br/>Playwright / Cypress<br/>核心场景覆盖"]
        Integration["集成测试<br/>pytest + httpx<br/>API层 + Service层"]
        Unit["单元测试<br/>pytest<br/>Domain层 + Infrastructure层"]
    end

    E2E --- Integration
    Integration --- Unit
```

### 9.2 各服务测试用例与验收标准

#### 9.2.1 模型管理服务

| 测试编号 | 测试用例 | 测试类型 | 验收标准 | 追溯需求 |
|---------|---------|---------|---------|---------|
| TC-M01 | 创建模型提供商 | 集成 | 提供商信息正确持久化到PostgreSQL | FR-3.7.1 |
| TC-M02 | 配置模型参数 | 集成 | 温度、Token限制等参数正确保存 | FR-3.7.2 |
| TC-M03 | 测试模型连通性 | 集成 | 成功调用LLM API并返回结果，响应 < 10s | FR-3.7.3 |
| TC-M04 | 模型调度-优先级 | 单元 | 按优先级选择可用模型 | FR-3.7.4 |
| TC-M05 | 模型调度-故障转移 | 集成 | 主模型不可用时自动切换备用模型 | FR-3.7.4 |
| TC-M06 | 调用日志记录 | 集成 | Token消耗、延迟、状态正确记录 | FR-3.7.5 |
| TC-M07 | API Key加密存储 | 单元 | API Key不以明文存储 | 安全要求 |
| TC-M08 | 模型连通性测试 | 集成 | 手动触发测试，返回连通状态和响应延迟 | FR-3.7.3 |

#### 9.2.2 提示词服务

| 测试编号 | 测试用例 | 测试类型 | 验收标准 | 追溯需求 |
|---------|---------|---------|---------|---------|
| TC-P01 | 创建提示词模板 | 集成 | 模板正确持久化，状态为"草稿" | FR-3.2.1 |
| TC-P02 | 编辑模板内容 | 集成 | 内容更新成功，版本号自增 | FR-3.2.2 |
| TC-P03 | 变量占位符解析 | 单元 | 正确识别并替换`{{variable}}`占位符 | FR-3.2.3 |
| TC-P04 | 本体字段引用 | 集成 | 引用本体属性时正确获取Schema信息 | FR-3.2.3 |
| TC-P05 | 提示词测试执行 | 集成 | 调用LLM返回结果，响应 < 30s | FR-3.2.4 |
| TC-P06 | 版本管理-创建 | 集成 | 版本快照正确保存 | FR-3.2.5 |
| TC-P07 | 版本管理-回滚 | 集成 | 回滚后内容恢复到指定版本 | FR-3.2.5 |
| TC-P08 | 分类管理 | 集成 | 支持3级分类树，拖拽排序 | FR-3.2.6 |
| TC-P09 | 模板复制 | 集成 | 复制后生成独立副本 | FR-3.2.1 |
| TC-P10 | 导入导出 | 集成 | JSON格式导入导出数据一致 | FR-3.2.7 |

#### 9.2.3 元本体服务

| 测试编号 | 测试用例 | 测试类型 | 验收标准 | 追溯需求 |
|---------|---------|---------|---------|---------|
| TC-O01 | 创建本体定义 | 集成 | 本体节点正确写入Neo4j | FR-3.4.1 |
| TC-O02 | 本体类型校验 | 单元 | 仅允许Level 1类型（Entity/Event/State/Observable/Rule/ModelConcept） | FR-3.4.1 |
| TC-O03 | 属性定义-14种数据类型 | 单元 | 所有数据类型正确校验 | FR-3.4.2 |
| TC-O04 | 属性定义-必填校验 | 单元 | 必填属性缺失时返回422 | FR-3.4.2 |
| TC-O05 | 关系类型管理 | 集成 | 29种预定义关系正确加载 | FR-3.4.3 |
| TC-O06 | 自定义关系类型 | 集成 | 用户自定义关系正确注册到Neo4j | FR-3.4.3 |
| TC-O07 | 本体分类树 | 集成 | 按类型分类，支持搜索过滤 | FR-3.4.4 |
| TC-O08 | 本体关系图数据 | 集成 | 返回G6兼容的节点/边数据 | FR-3.4.5 |
| TC-O09 | 版本快照 | 集成 | 快照包含完整本体定义 | FR-3.4.6 |
| TC-O10 | 版本回滚 | 集成 | 回滚后本体恢复到指定版本 | FR-3.4.6 |
| TC-O11 | 孤立本体检查 | 集成 | 正确检测无关系连接的节点 | FR-3.4.7 |
| TC-O12 | 本体名称唯一性 | 集成 | 同类型下名称不可重复 | FR-3.4.1 |

#### 9.2.4 知识图谱服务

| 测试编号 | 测试用例 | 测试类型 | 验收标准 | 追溯需求 |
|---------|---------|---------|---------|---------|
| TC-K01 | 创建知识节点 | 集成 | 节点遵循本体Schema，正确写入Neo4j | FR-3.6.1 |
| TC-K02 | Schema约束校验 | 集成 | 属性不符合本体定义时返回422 | FR-3.6.1 |
| TC-K03 | 建立知识关系 | 集成 | 关系类型和方向正确 | FR-3.6.1 |
| TC-K04 | 图可视化数据 | 集成 | 返回G6格式数据，节点数 < 2000时响应 < 2s | FR-3.6.2 |
| TC-K05 | 批量导入-JSON | 集成 | 100条数据导入成功，Schema校验通过 | FR-3.6.4 |
| TC-K06 | 批量导入-CSV | 集成 | CSV格式正确解析并导入 | FR-3.6.4 |
| TC-K07 | 知识导出 | 集成 | 导出数据与导入数据一致 | FR-3.6.4 |
| TC-K08 | Cypher直接查询 | 集成 | 合法Cypher正确执行并返回结果 | FR-3.6.3 |

#### 9.2.5 RAG查询服务

| 测试编号 | 测试用例 | 测试类型 | 验收标准 | 追溯需求 |
|---------|---------|---------|---------|---------|
| TC-R01 | Function Calling-A组 | 集成 | 能力范围内查询准确率 >= 90% | FR-3.6.3 |
| TC-R02 | Function Calling-B组 | 集成 | 能力边界识别率 >= 85%（降级率） | FR-3.6.3 |
| TC-R03 | Fallback-API超时(FB-1) | 集成 | 超时后切换备用模型，仍失败触发Auto Cypher | FR-3.6.3 |
| TC-R04 | Fallback-API错误(FB-2) | 集成 | 故障转移到备用模型，仍失败触发Auto Cypher | FR-3.6.3 |
| TC-R05 | Fallback-API限流(FB-3) | 集成 | 等待重试，超过3次触发Auto Cypher | FR-3.6.3 |
| TC-R06 | Fallback-功能限制(FB-4) | 集成 | LLM拒绝回答时直接触发Fallback | FR-3.6.3 |
| TC-R07 | Fallback-空结果(FB-5) | 集成 | 查询结果为空时触发Fallback | FR-3.6.3 |
| TC-R08 | Fallback-不完整回答(FB-6) | 集成 | LLM返回文本而非function_call时触发Fallback | FR-3.6.3 |
| TC-R09 | Auto Cypher生成 | 集成 | 生成的Cypher语法正确且可执行 | FR-3.6.3 |
| TC-R10 | SSE流式响应 | 集成 | 进度事件正确推送，结果事件包含完整数据 | 架构要求 |
| TC-R11 | 端到端查询延迟 | 性能 | 单次查询响应 < 45s（含Fallback） | 性能要求 |
| TC-R12 | 查询日志记录 | 集成 | 查询意图、路径、Fallback原因、结果正确记录 | FR-3.6.3 |

---

## 10. 演进路径

### 10.1 P0阶段实现范围

**交付物清单**：

| 模块 | 交付内容 | 优先级 |
|------|---------|--------|
| 模型管理服务 | 提供商管理、模型配置、连通性测试、调度器、调用日志 | P0-1（最高） |
| 提示词服务 | 模板CRUD、分类管理、模板渲染、版本管理、验证与测试 | P0-2 |
| 元本体服务 | 本体定义CRUD、属性建模、关系管理、分类树、关系图数据、可视化建模支持、**AI辅助建模（P0核心）**、版本管理 | P0-3 |
| 知识图谱服务 | **知识自动化提取（P0核心）**、知识节点CRUD、关系管理、图可视化数据、导入导出、自然语言查询（委托RAG） | P0-4 |
| RAG查询服务（内部） | Function Calling工具集构建、Auto Cypher生成、Fallback控制器 | P0-4 |
| 前端-模型管理 | 提供商列表、模型配置表单、连通性测试、监控面板 | P0-1 |
| 前端-提示词管理 | 模板列表、Monaco编辑器、测试面板、版本历史 | P0-2 |
| 前端-元本体管理 | 本体列表、编辑表单、G6关系图、分类树、**AI建模建议预览与确认** | P0-3 |
| 前端-知识图谱 | G6图画布、节点编辑、导入向导、**知识提取预览与确认** | P0-4 |

### 10.2 P1/P2阶段扩展预留

**P0阶段为P1/P2预留的扩展点**：

| 扩展点 | P0预留设计 | P1/P2实现内容 |
|--------|-----------|--------------|
| **分析引擎接口** | Service层预留`AnalysisService`抽象接口 | 实现场景化分析引擎，编排提示词+模型+知识 |
| **场景模板接口** | 提示词服务支持模板渲染 | 新增场景模板管理，绑定提示词+报告模板 |
| **报告生成接口** | API路由预留`/api/v1/reports` | 实现Markdown/HTML/PDF报告生成 |
| **证据链追溯** | RAG查询记录查询路径和结果 | 实现证据链可视化，推理过程回溯 |
| **多模态处理** | 文档处理预留多格式解析接口 | 实现PDF/Word/图片解析，VLM集成 |
| **向量检索** | Milvus已部署，RAG服务预留向量检索接口 | 实现文本向量化+混合检索（Method 3） |
| **WebSocket** | 前端预留WS Client | 实现分析进度实时推送 |

### 10.3 P3阶段平台化考量

| 平台化需求 | 架构影响 | P0阶段准备 |
|-----------|---------|-----------|
| **多租户** | 数据隔离、配置隔离 | P0使用单租户，数据模型预留tenant_id字段 |
| **用户权限** | RBAC权限模型 | P0无认证，API网关预留认证中间件插槽 |
| **开放API** | API Key管理、限流 | P0使用RESTful规范，便于后续开放 |
| **场景市场** | 模板打包、发布、订阅 | P0场景模板设计为独立可导出单元 |
| **水平扩展** | 无状态服务、负载均衡 | P0服务设计为无状态，Session不存储在内存 |
| **审计日志** | 操作追溯 | P0记录关键操作日志（模型调用、知识变更） |

---

## 11. 风险与决策记录

### 11.1 关键架构决策记录（ADR）

#### ADR-001: P0阶段采用单体部署而非微服务

- **状态**: 已决定
- **背景**: P0阶段有5个后端服务，需要决定部署架构
- **决策**: 采用单体部署（单FastAPI进程），服务间通过Python模块调用
- **理由**:
  - P0阶段并发需求仅10用户，单进程足够
  - 避免微服务带来的运维复杂度（服务发现、网关、链路追踪）
  - 开发效率高，调试方便
  - 服务边界已在代码层面清晰划分，后续可平滑拆分
- **后果**: P3阶段需要支持100+并发时，需拆分为独立服务

#### ADR-002: 采用Neo4j + PostgreSQL双库策略

- **状态**: 已决定
- **背景**: 系统同时需要图结构存储（本体/知识）和关系型存储（配置/日志）
- **决策**: Neo4j存储本体定义和知识图谱，PostgreSQL存储系统配置和业务数据
- **理由**:
  - Neo4j天然适合图结构的本体和知识图谱，Cypher查询表达力强
  - PostgreSQL适合结构化配置数据，事务支持完善
  - 两个数据库已在服务器部署就绪
  - 避免用单一数据库勉强适配两种数据模式
- **后果**: 需要维护两套数据访问层，跨库事务需要应用层保证一致性

#### ADR-003: RAG方案选择Method 5（Function Calling + Fallback）

- **状态**: 已决定
- **背景**: 需要实现自然语言到知识图谱查询的转换，PRD要求Fallback机制
- **决策**: 采用Method 5（Function Calling优先 + Auto Cypher Fallback）
- **理由**:
  - 技术调研实验验证：B组降级识别率94.4%
  - 成本较纯Auto Cypher（Method 4）节省56%
  - 性能较Method 4提升47%
  - 满足PRD中FR-3.6.3的Fallback机制要求
  - 提示词工程原则已验证：让模型基于函数签名判断，强调准确性
- **后果**: 需要维护Function Calling工具集和Auto Cypher生成器两套机制

#### ADR-004: 元本体采用三层架构（Level 0/1/2）

- **状态**: 已决定
- **背景**: 需要设计灵活可扩展的本体模型架构
- **决策**: Level 0（元模型，Python代码）、Level 1（业务元本体，Neo4j）、Level 2（心理领域，Neo4j）
- **理由**:
  - Level 0代码实现保证核心框架稳定性，不受用户操作影响
  - Level 1/2存储在Neo4j，支持用户通过UI自由建模
  - 三层分离使得领域扩展（如教育心理学、犯罪心理学）只需新增Level 2定义
  - 关系类型采用混合管理：Python枚举（29种预定义）+ Neo4j元数据（用户扩展）
- **后果**: Level 0变更需要代码发布，Level 1/2变更通过UI即时生效

### 11.2 风险识别与缓解

| 风险编号 | 风险描述 | 影响等级 | 概率 | 缓解策略 |
|---------|---------|---------|------|---------|
| R-01 | LLM API不稳定（超时/限流/服务中断） | 高 | 中 | 多模型提供商故障转移；Fallback机制；本地缓存热点查询结果 |
| R-02 | Neo4j单点故障 | 高 | 低 | P0阶段定期备份；P3阶段部署集群模式 |
| R-03 | Function Calling准确率不达标 | 中 | 中 | 持续优化提示词；扩充Function工具集；Auto Cypher兜底 |
| R-04 | 图可视化性能瓶颈（大规模节点） | 中 | 中 | G6虚拟滚动；节点聚合；分页加载；限制单次渲染节点数 |
| R-05 | 元本体Schema变更导致知识数据不一致 | 高 | 中 | 版本管理；变更影响分析；Schema迁移工具 |
| R-06 | LLM调用成本超预算 | 中 | 中 | Token消耗监控；模型调度优先使用低成本模型；缓存重复查询 |
| R-07 | 前后端开发进度不同步 | 中 | 高 | API契约先行（OpenAPI规范）；Mock Server；并行开发 |
| R-08 | 元本体约束验证失败（复杂规则校验不通过） | 中 | 中 | 应用层分级校验（基础校验 + 业务校验）；校验失败返回明确错误信息；预留校验规则热更新 |
| R-09 | 跨库数据不一致（PG与Neo4j数据不同步） | 高 | 中 | Service层同步更新策略；pre_delete_check前置检查；关键操作记录审计日志；P1预留事件驱动同步 |
| R-10 | RAG查询超时导致前端无响应 | 中 | 高 | SSE流式响应实时反馈进度；Nginx超时配置调整（proxy_read_timeout >= 60s）；前端超时提示与重试机制 |

---

## 附录

### 附录A：技术依赖清单

#### 后端依赖

| 包名 | 版本 | 用途 |
|------|------|------|
| fastapi | >= 0.100 | Web框架 |
| uvicorn | >= 0.23 | ASGI服务器 |
| pydantic | >= 2.0 | 数据校验 |
| langchain | >= 0.2 | LLM应用框架 |
| neo4j | >= 5.0 | Neo4j Python驱动 |
| psycopg2-binary | >= 2.9 | PostgreSQL驱动 |
| sqlalchemy | >= 2.0 | ORM框架 |
| alembic | >= 1.12 | 数据库迁移 |
| httpx | >= 0.25 | 异步HTTP客户端 |
| python-dotenv | >= 1.0 | 环境变量管理 |
| cryptography | >= 41.0 | API Key加密 |

#### 前端依赖

| 包名 | 版本 | 用途 |
|------|------|------|
| react | >= 18.2 | UI框架 |
| react-dom | >= 18.2 | DOM渲染 |
| react-router-dom | >= 6.0 | 路由管理 |
| antd | >= 5.0 | UI组件库 |
| @ant-design/icons | >= 5.0 | 图标库 |
| zustand | >= 4.4 | 状态管理 |
| axios | >= 1.5 | HTTP客户端 |
| @antv/g6 | 4.8.x | 图可视化引擎（P0阶段；P2评估升级5.x） |
| @monaco-editor/react | >= 4.6 | 代码编辑器 |
| typescript | >= 5.0 | 类型系统 |
| vite | >= 5.0 | 构建工具 |

### 附录B：基础设施连接信息

| 服务 | 连接地址 | 认证信息 |
|------|---------|---------|
| Neo4j Browser | `http://192.168.176.128:7474` | 无需认证 |
| Neo4j Bolt | `bolt://192.168.176.128:7687` | 无需认证 |
| PostgreSQL | `postgresql://testuser:123456@192.168.176.128:5432/testdb` | testuser / 123456 |
| Milvus Attu | `http://192.168.176.128:8000` | 无需认证 |
| Milvus gRPC | `192.168.176.128:19530` | 无需认证 |

---

**文档结束**

> 本文档基于以下输入文档编写：
> - 心理分析系统_产品需求文档_v2.0.md
> - 心理分析系统_P0阶段交互需求设计_v2.0.md
> - 元本体数据模型需求文档_v1.0.md
> - Neo4j_RAG技术调研报告_完整版.md
> - 数据库服务快速访问指南.md
>
> 如有疑问或需要更新，请联系架构设计负责人。
