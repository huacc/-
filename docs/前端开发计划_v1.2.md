# 心理分析系统 - 前端详细开发计划 v1.2（增量可视化版）

> **版本**: v1.2
> **文档类型**: 前端详细开发计划（基于Demo增量可视化开发）
> **创建日期**: 2026-02-17
> **状态**: 待评审
> **适用阶段**: P0 MVP基础版
> **Demo项目路径**: `d:\项目\AI中台\demo\psychanalysis-ai-platform`
> **核心原则**: 每个阶段都有可交互和可渲染的产出，避免积累bug

---

## 文档说明

本文档是心理分析系统前端的**增量可视化开发计划**，基于AI Studio生成的Demo项目进行增量开发。

### 核心原则

**🎯 每个任务完成后都能在浏览器看到变化**

1. **先UI后逻辑** - 先让界面可交互，再连接真实数据
2. **增量可视化** - 每次只改一小部分，立即验证
3. **避免积累bug** - 每个阶段都能运行和测试，问题立即暴露
4. **AI Studio友好** - 任务粒度小，目标明确，易于实现

### Demo项目现状

**✅ 已完成部分**（AI Studio已生成）：
- 基础框架：Layout + Header + Sidebar + 路由导航
- 页面UI框架：Dashboard, Model, Prompt, Ontology, Knowledge
- 视觉风格：Tailwind CSS，现代简洁设计
- 交互模式：Tab切换、左侧树+右侧详情、三栏布局

**❌ 待补充部分**（v1.2开发重点）：
- 数据交互：API调用、Mock数据
- 核心功能：表单CRUD、图可视化（G6）、代码编辑器（Monaco）
- 高级功能：提示词测试、性能监控

### 任务描述格式

每个任务都包含以下部分：

```
### 任务X.X: [功能名称]

**🎨 本次可见产出**：
- 在浏览器中能看到什么变化
- 能进行什么交互操作

**实现目标**：在[页面/组件]实现[功能]

**技术约束**：
- 必须使用的技术/库
- 参考的设计文档章节

**验收方案**：
- [ ] 功能验收：具体功能点
- [ ] 交互验收：具体交互行为
- [ ] 视觉验收：具体视觉效果
```

---

## 模块功能规格说明

> **MBSE追溯**: 本章节定义所有模块的完整功能清单，每个功能都有唯一ID，后续开发阶段将明确标注实现的功能ID

### M1. 模型管理模块功能清单

#### M1.1 模型列表管理
- **M1.1.1** 模型卡片展示：显示模型名称、提供商、版本、类型、状态、成功率、平均响应时间
- **M1.1.2** 模型搜索：支持按名称、提供商搜索，300ms防抖
- **M1.1.3** 模型过滤：支持按状态过滤（全部/正常/异常/维护中）
- **M1.1.4** 模型配置Modal：弹窗表单，包含基本信息、API配置、默认参数、使用限制
- **M1.1.5** 模型创建：填写表单创建新模型，保存到localStorage/后端
- **M1.1.6** 模型编辑：预填充数据，修改后保存
- **M1.1.7** 模型删除：二次确认后删除
- **M1.1.8** 测试连接：验证API Key和端点可用性

#### M1.2 调度策略管理（v1.2暂不实现）
- **M1.2.1** 默认调度策略配置：质量优先/平衡选择/速度优先/成本优先
- **M1.2.2** 任务类型映射：为不同任务类型指定首选和备用模型
- **M1.2.3** 负载均衡配置：负载阈值、重试策略

#### M1.3 性能监控（v1.2暂不实现）
- **M1.3.1** 关键指标概览：总请求数、成功率、平均响应时间、总成本
- **M1.3.2** 性能对比图表：多模型响应时间趋势折线图
- **M1.3.3** 模型详细统计：表格展示各模型详细指标
- **M1.3.4** 告警记录：显示异常和告警信息

---

### M2. 提示词管理模块功能清单

#### M2.1 提示词编辑器
- **M2.1.1** Monaco Editor集成：替换textarea，支持Markdown语法高亮
- **M2.1.2** 变量高亮：`{{variable}}`格式文本特殊高亮显示
- **M2.1.3** 自动提取变量：从编辑器内容提取变量到测试面板
- **M2.1.4** 基本信息编辑：提示词名称、所属分类、标签
- **M2.1.5** 字数和Token估算：实时显示字数和Token数量

#### M2.2 提示词测试
- **M2.2.1** 模型选择：下拉框选择可用模型
- **M2.2.2** 变量输入：根据提取的变量动态生成输入表单
- **M2.2.3** 参数配置：Temperature、Max Tokens、Top P等参数
- **M2.2.4** 执行测试：调用LLM API，显示Loading状态
- **M2.2.5** 流式响应展示：SSE流式响应，打字机效果
- **M2.2.6** 测试结果操作：复制结果、显示耗时和Token统计
- **M2.2.7** 错误处理：测试失败时显示红色错误信息

#### M2.3 分类树管理（v1.2暂不实现）
- **M2.3.1** 分类树展示：显示提示词分类层级结构
- **M2.3.2** 分类CRUD：创建、编辑、删除分类
- **M2.3.3** 分类搜索：模糊搜索分类和提示词
- **M2.3.4** 收藏和最近使用：快速访问常用提示词

#### M2.4 版本管理（v1.2暂不实现）
- **M2.4.1** 版本历史：显示所有历史版本
- **M2.4.2** 版本对比：选择两个版本进行对比
- **M2.4.3** 版本回滚：恢复到指定版本

---

### M3. 元本体管理模块功能清单

#### M3.1 本体定义管理
- **M3.1.1** 分类树展示：显示本体分类层级（Entity/Event/State等）
- **M3.1.2** 分类树交互：展开/收起、选中高亮、搜索过滤
- **M3.1.3** 本体列表展示：点击分类显示该分类下的本体
- **M3.1.4** 基本信息编辑：本体名称、类型、描述
- **M3.1.5** 属性定义：动态表单，添加/删除属性（属性名、类型、必填、默认值）
- **M3.1.6** 关系定义：动态表单，添加/删除关系（关系名、目标本体、关系类型）
- **M3.1.7** 本体创建：填写表单创建新本体
- **M3.1.8** 本体编辑：预填充数据，修改后保存
- **M3.1.9** 本体删除：二次确认后删除
- **M3.1.10** 数据验证：名称不为空、类型必选、属性名不重复、关系目标存在

#### M3.2 本体关系图可视化
- **M3.2.1** G6图谱集成：使用@antv/g6 4.8.x渲染图谱
- **M3.2.2** 节点展示：圆角矩形，显示本体名称和类型，不同类型不同颜色
- **M3.2.3** 边展示：箭头连线，显示关系类型
- **M3.2.4** 工具栏：选择、拖拽、缩放、适应画布按钮
- **M3.2.5** 节点交互：点击高亮、双击显示详情、拖拽调整位置
- **M3.2.6** 画布交互：缩放、平移、适应画布
- **M3.2.7** 加载真实数据：从Mock数据加载10-15个节点和边
- **M3.2.8** 布局算法：力导向布局（Force-Directed）

#### M3.3 版本管理（v1.2暂不实现）
- **M3.3.1** 本体层版本管理：创建、查看、对比、回滚
- **M3.3.2** 知识库层版本管理：创建、查看、对比、回滚

#### M3.4 孤立本体检查（v1.2暂不实现）
- **M3.4.1** 孤立检查：扫描没有关系连接的本体
- **M3.4.2** 修复建议：提供快速修复建议

---

### M4. 知识图谱模块功能清单

#### M4.1 知识图谱画布
- **M4.1.1** G6画布集成：使用@antv/g6 4.8.x渲染知识图谱
- **M4.1.2** 节点展示：圆角矩形，显示实例名称和本体类型，颜色与本体类型对应
- **M4.1.3** 边展示：带箭头曲线，显示关系类型
- **M4.1.4** 画布工具栏：搜索、放大、缩小、适应画布按钮
- **M4.1.5** 搜索功能：按节点名称搜索并高亮
- **M4.1.6** 缩放控制：放大/缩小/适应画布
- **M4.1.7** 节点交互：单击选中、双击展开相邻节点、拖拽调整位置
- **M4.1.8** 边交互：点击边高亮，显示边详情
- **M4.1.9** 画布交互：拖拽平移、滚轮缩放、框选多个节点

#### M4.2 节点管理
- **M4.2.1** 节点创建表单：选择本体类型、填写名称和属性
- **M4.2.2** 动态属性字段：根据本体类型动态生成属性输入框
- **M4.2.3** 创建节点：提交表单，节点添加到画布中心
- **M4.2.4** 节点详情展示：点击节点在右侧显示详情
- **M4.2.5** 节点编辑：修改节点属性，保存更新
- **M4.2.6** 节点删除：二次确认后删除，关联边一起删除

#### M4.3 关系管理
- **M4.3.1** 关系创建表单：选中两个节点后填写关系类型和属性
- **M4.3.2** 多选节点：Ctrl+点击选择多个节点
- **M4.3.3** 创建关系：提交表单，画布中显示新连线
- **M4.3.4** 关系详情展示：点击边在右侧显示详情
- **M4.3.5** 关系编辑：修改关系属性，保存更新
- **M4.3.6** 关系删除：二次确认后删除

#### M4.4 AI助手（v1.2暂不实现）
- **M4.4.1** 基于本体生成：选择本体类型和数量，AI生成知识实例
- **M4.4.2** 从文档提取：上传文档，AI提取实体和关系
- **M4.4.3** 生成结果预览：预览生成的节点和关系
- **M4.4.4** 应用到画布：确认后将结果添加到知识图谱

#### M4.5 查询工具（v1.2暂不实现）
- **M4.5.1** 自然语言查询：输入自然语言，AI生成Cypher查询
- **M4.5.2** Cypher查询：Monaco编辑器编写Cypher查询
- **M4.5.3** 查询执行：执行查询，返回结果
- **M4.5.4** 结果展示：列表展示查询结果，支持在画布中高亮
- **M4.5.5** 查询模板：提供常用查询模板

#### M4.6 知识导入导出（v1.2暂不实现）
- **M4.6.1** 导入功能：支持JSON/CSV格式导入
- **M4.6.2** 导出功能：支持JSON/CSV格式导出

---

## 阶段划分总览

| 阶段 | 名称 | 核心产出 | 预估工作量 |
|------|------|---------|-----------|
| **Phase 0** | Demo现状确认 | 验证Demo可运行 | 0.5天 |
| **Phase 1** | 模型管理数据化 | 模型列表显示真实数据，可搜索过滤 | 2天 |
| **Phase 2** | 模型管理表单化 | 可创建/编辑/删除模型 | 2天 |
| **Phase 3** | 提示词编辑器升级 | Monaco编辑器替换textarea | 2天 |
| **Phase 4** | 提示词测试功能 | 可在线测试提示词，看到流式响应 | 2天 |
| **Phase 5** | 本体图谱可视化 | G6图谱替换占位符 | 2天 |
| **Phase 6** | 本体管理功能 | 可创建/编辑本体定义 | 2天 |
| **Phase 7** | 知识图谱画布 | G6画布替换占位符，可拖拽节点 | 3天 |
| **Phase 8** | 知识图谱操作 | 可创建/编辑节点和边 | 2天 |
| **Phase 9** | 状态管理优化 | 添加全局状态管理 | 2天 |
| **Phase 10** | 测试与部署 | 测试、优化、Docker | 3天 |
| **总计** | - | - | **22.5天** |

---

## 详细阶段规划

### Phase 0: Demo现状确认（0.5天）

**🎨 本次可见产出**：
- 浏览器打开 `http://localhost:3000` 能看到完整界面
- 所有页面可访问，导航可切换
- 确认Demo的UI质量和代码结构

**实现目标**：验证Demo项目可正常运行，记录现状

**技术约束**：
- 保持Demo项目原有技术栈
- 不修改任何代码

**验收方案**：
- [ ] 功能验收：项目可启动，5个页面可访问，导航正常
- [ ] 代码验收：代码结构清晰，无明显质量问题
- [ ] 文档验收：记录目录结构、已实现功能、待补充功能

---

### Phase 1: 模型管理数据化（2天）

#### 任务1.1: 创建Mock数据服务

**📋 实现功能**：M1.1.1（模型卡片展示）

**🎨 本次可见产出**：
- Model页面显示6个真实的模型卡片（不再是硬编码的2个）
- 每个模型有完整的信息（名称、版本、状态、成功率、响应时间）

**实现目标**：
在 `pages/Model.tsx` 中，使用Mock数据替换硬编码的模型列表

**功能详细说明**：
1. **数据结构定义**：
   - 模型ID（唯一标识）
   - 模型名称（如"OpenAI GPT-4o"）
   - 提供商（如"OpenAI"）
   - 版本（如"gpt-4o-2024-05-13"）
   - 类型（LLM/VLM）
   - 状态（normal/error/maintenance）
   - 成功率（百分比，如99.2）
   - 平均响应时间（秒，如2.3）
   - 成本信息（输入/输出每1K tokens的价格）

2. **Mock数据内容**（至少6个模型）：
   - OpenAI GPT-4o: LLM, 正常, 99.2%, 2.3s
   - Anthropic Claude 3.5 Sonnet: LLM, 正常, 98.8%, 1.8s
   - Google Gemini 2.0 Flash: VLM, 限流中, 95.5%, 3.1s
   - 阿里通义千问: LLM, 正常, 97.5%, 2.5s
   - 百度文心一言: LLM, 正常, 96.8%, 2.8s
   - 字节豆包: LLM, 正常, 98.1%, 2.2s

3. **卡片展示规格**：
   - 左上角：模型图标（2-3个字母缩写）+ 模型名称
   - 名称下方：版本信息和类型标签
   - 右上角：状态标签（颜色编码：正常🟢/异常🔴/维护🟡）
   - 底部：成功率和平均响应时间
   - 右下角：操作按钮（测试连接、配置、删除）

**技术约束**：
- 使用简单的mock函数或MSW 2.x
- Mock数据存储在 `src/mocks/modelData.ts`
- 状态标签颜色：正常(green-600)、异常(red-600)、维护(yellow-600)

**验收方案**：
- [ ] 功能验收：页面加载时显示6个模型卡片
- [ ] 数据验收：每个模型包含完整字段（id, name, provider, version, status, successRate, avgLatency）
- [ ] 视觉验收：卡片布局保持现有设计，状态标签颜色正确

#### 任务1.2: 实现搜索和过滤功能

**📋 实现功能**：M1.1.2（模型搜索）

**🎨 本次可见产出**：
- 页面顶部有搜索框（如果没有则添加）
- 输入关键词可实时过滤模型列表
- 无匹配结果时显示"未找到模型"提示

**实现目标**：
在 `pages/Model.tsx` 中，添加搜索框和过滤逻辑

**功能详细说明**：
1. **搜索框位置**：页面顶部，Tab导航下方，模型列表上方
2. **搜索范围**：
   - 模型名称（如"GPT-4o"）
   - 提供商名称（如"OpenAI"）
3. **搜索行为**：
   - 实时搜索：输入时立即触发过滤
   - 防抖处理：300ms延迟，避免频繁触发
   - 大小写不敏感
   - 支持部分匹配（包含关系）
4. **搜索结果展示**：
   - 匹配的模型卡片正常显示
   - 不匹配的模型卡片隐藏
   - 无匹配结果时显示空状态："未找到匹配的模型"
5. **清空搜索**：
   - 清空搜索框内容时恢复显示所有模型
   - 搜索框右侧有清空按钮（×图标）

**技术约束**：
- 搜索有防抖处理（300ms）
- 使用 `lodash.debounce` 或自定义防抖函数
- 空状态提示使用灰色文字，居中显示

**验收方案**：
- [ ] 功能验收：搜索框输入后300ms触发过滤，列表实时更新
- [ ] 交互验收：清空搜索框恢复完整列表
- [ ] 视觉验收：无结果时显示空状态提示

---

#### 任务1.3: 添加状态过滤器

**📋 实现功能**：M1.1.3（模型过滤）

**🎨 本次可见产出**：
- 搜索框旁边有状态过滤下拉框（全部/正常/异常/维护中）
- 选择状态可过滤模型列表
- 过滤器和搜索框可组合使用

**实现目标**：
在 `pages/Model.tsx` 中，添加状态过滤下拉框

**功能详细说明**：
1. **过滤器位置**：搜索框右侧
2. **过滤选项**：
   - 全部（默认选中，显示所有模型）
   - 正常（status='normal'）
   - 异常（status='error'）
   - 维护中（status='maintenance'）
3. **过滤行为**：
   - 选择状态后立即过滤列表
   - 与搜索框组合使用：先按状态过滤，再按搜索关键词过滤
   - 过滤逻辑：AND关系（同时满足状态和搜索条件）
4. **过滤结果展示**：
   - 匹配的模型卡片正常显示
   - 不匹配的模型卡片隐藏
   - 无匹配结果时显示空状态
5. **状态统计**（可选）：
   - 在过滤器选项中显示每个状态的模型数量
   - 如"正常 (4)"、"异常 (1)"

**技术约束**：
- 使用简单的select或自定义下拉组件
- 过滤逻辑与搜索逻辑组合（先状态过滤，再关键词过滤）
- 下拉框样式与搜索框高度一致

**验收方案**：
- [ ] 功能验收：状态过滤器可切换，列表正确过滤
- [ ] 交互验收：过滤器和搜索框组合使用正常
- [ ] 视觉验收：过滤器样式与整体风格一致

---

### Phase 2: 模型管理表单化（2天）

#### 任务2.1: 添加模型配置Modal

**📋 实现功能**：M1.1.4（模型配置Modal）

**🎨 本次可见产出**：
- 点击页面上的"新建模型"按钮（如果没有则添加），弹出配置Modal
- Modal中显示完整的表单字段（名称、提供商、API Key、模型版本、超时设置等）
- 表单可填写，必填项有红色星号标记

**实现目标**：
创建新组件 `components/ModelConfigModal.tsx`，实现模型配置表单

**功能详细说明**：
1. **Modal触发**：
   - 在Model页面顶部添加"新建模型"按钮
   - 按钮样式：品牌色背景，白色文字，带"+"图标
   - 点击按钮打开Modal

2. **Modal布局**：
   - 居中显示，宽度600px
   - 半透明黑色遮罩（bg-black/50）
   - 白色背景，圆角边框，阴影效果
   - 顶部：标题"新建模型"，右上角关闭按钮（×）
   - 中间：表单区域，可滚动
   - 底部：取消和保存按钮

3. **表单字段**（分4个区域）：

   **基本信息区域**：
   - 模型名称（必填）：文本输入框，placeholder "如：OpenAI GPT-4o"
   - 提供商（必填）：下拉选择，选项：OpenAI/Anthropic/Google/阿里/百度/字节
   - 模型版本（必填）：文本输入框，placeholder "如：gpt-4o-2024-05-13"
   - 模型类型（必填）：单选按钮，选项：LLM/VLM

   **API配置区域**：
   - API端点（必填）：文本输入框，placeholder "https://api.openai.com/v1"
   - API Key（必填）：密码输入框，带"显示/隐藏"切换按钮
   - 组织ID（可选）：文本输入框

   **默认参数区域**：
   - 超时时间（必填）：数字输入框，默认60，单位秒
   - 最大Token（必填）：数字输入框，默认4096
   - Temperature（可选）：滑块，范围0-2，默认0.7
   - Top P（可选）：滑块，范围0-1，默认1

   **使用限制区域**：
   - 每分钟请求数（可选）：数字输入框，默认60
   - 每天请求数（可选）：数字输入框，默认10000
   - 成本预算（可选）：数字输入框，单位元/天

4. **表单验证**：
   - 必填项为空时，字段下方显示红色错误提示
   - 必填项标签后有红色星号（*）
   - 保存按钮状态：必填项未填写时禁用（灰色，不可点击）

5. **交互行为**：
   - 点击遮罩或关闭按钮：关闭Modal
   - 点击取消按钮：关闭Modal，不保存
   - 点击保存按钮：触发验证，验证通过后保存（下一任务实现）

**技术约束**：
- 使用Tailwind样式，保持与Demo一致的视觉风格
- Modal组件可使用Headless UI或自定义实现
- 表单状态管理使用React useState

**验收方案**：
- [ ] 功能验收：Modal可打开/关闭，表单字段完整（4个区域，15个字段）
- [ ] 交互验收：点击Modal外部或取消按钮可关闭，必填项为空时保存按钮禁用
- [ ] 视觉验收：Modal居中显示，有半透明遮罩，表单布局清晰，分区明确

#### 任务2.2: 实现表单验证和提交

**📋 实现功能**：M1.1.5（模型创建）

**🎨 本次可见产出**：
- 必填项为空时显示红色错误提示
- API Key格式错误时显示提示
- 点击"保存"后，Modal关闭，列表中新增一条模型卡片
- 右上角显示"创建成功"Toast提示

**实现目标**：
在 `components/ModelConfigModal.tsx` 中，实现表单验证和Mock保存

**功能详细说明**：
1. **表单验证规则**：
   - **模型名称**：不能为空，长度2-50字符
   - **提供商**：必须选择一个选项
   - **模型版本**：不能为空，长度2-100字符
   - **模型类型**：必须选择LLM或VLM
   - **API端点**：不能为空，必须是有效的URL格式（以http://或https://开头）
   - **API Key**：不能为空，长度至少16字符
   - **超时时间**：必须是正整数，范围10-300秒
   - **最大Token**：必须是正整数，范围100-128000

2. **验证触发时机**：
   - 实时验证：字段失去焦点（onBlur）时触发
   - 提交验证：点击保存按钮时触发全部字段验证
   - 错误提示：在字段下方显示红色文字，如"模型名称不能为空"

3. **保存逻辑**：
   - 点击保存按钮，先执行全部字段验证
   - 验证失败：显示错误提示，保持Modal打开
   - 验证成功：
     - 生成唯一ID（使用Date.now()或UUID）
     - 初始化状态为"normal"
     - 初始化成功率为0%，平均响应时间为0s
     - 将模型数据保存到localStorage（key: "models"）
     - 关闭Modal
     - 刷新模型列表（从localStorage读取）
     - 显示Toast提示："创建成功"

4. **数据存储格式**（localStorage）：
   ```json
   {
     "models": [
       {
         "id": "1708234567890",
         "name": "OpenAI GPT-4o",
         "provider": "OpenAI",
         "version": "gpt-4o-2024-05-13",
         "type": "LLM",
         "apiEndpoint": "https://api.openai.com/v1",
         "apiKey": "sk-***",
         "organizationId": "",
         "timeout": 60,
         "maxTokens": 4096,
         "temperature": 0.7,
         "topP": 1,
         "rpmLimit": 60,
         "dailyLimit": 10000,
         "costBudget": 100,
         "status": "normal",
         "successRate": 0,
         "avgLatency": 0,
         "createdAt": "2024-02-17T10:30:00Z"
       }
     ]
   }
   ```

5. **Toast提示规格**：
   - 位置：屏幕右上角
   - 样式：绿色背景，白色文字，圆角，阴影
   - 显示时长：3秒后自动消失
   - 可手动关闭（×按钮）

**技术约束**：
- 使用localStorage存储Mock数据（key: "models"）
- 表单验证使用自定义验证函数或React Hook Form
- Toast组件可使用react-hot-toast或自定义实现

**验收方案**：
- [ ] 功能验收：验证规则生效（8个必填项），保存后列表新增记录，数据持久化到localStorage
- [ ] 交互验收：错误提示实时显示，保存成功显示Toast，3秒后自动消失
- [ ] 视觉验收：错误提示为红色，Toast为绿色，位置和样式符合规格

#### 任务2.3: 实现模型编辑和删除

**📋 实现功能**：M1.1.6（模型编辑）、M1.1.7（模型删除）

**🎨 本次可见产出**：
- 点击卡片上的"配置"按钮，打开编辑Modal，表单预填充当前模型数据
- 修改后保存，卡片信息立即更新
- 点击"删除"按钮（需在卡片上添加），显示确认对话框
- 确认删除后，卡片从列表中消失

**实现目标**：
扩展 `components/ModelConfigModal.tsx` 支持编辑模式，在卡片上添加删除按钮

**功能详细说明**：
1. **编辑功能实现**：
   - **触发方式**：点击模型卡片右侧的"配置"按钮
   - **Modal标题**：从"新建模型"改为"编辑模型"
   - **表单预填充**：
     - 从localStorage读取当前模型的完整数据
     - 将所有字段值填充到表单中
     - API Key显示为"sk-***"（脱敏），可选择"重新输入"
   - **保存逻辑**：
     - 验证规则与创建相同
     - 验证成功后，更新localStorage中对应ID的模型数据
     - 保留原有的id、createdAt、status、successRate、avgLatency
     - 更新updatedAt字段为当前时间
     - 关闭Modal，刷新列表
     - 显示Toast："更新成功"

2. **删除功能实现**：
   - **删除按钮位置**：在模型卡片右侧操作区，"配置"按钮旁边
   - **删除按钮样式**：红色边框，红色文字，hover时背景变为浅红色
   - **删除按钮文字**："删除"
   - **确认对话框**：
     - 点击删除按钮后，弹出确认对话框
     - 对话框标题："确认删除"
     - 对话框内容："确定要删除模型 [模型名称] 吗？此操作不可恢复。"
     - 对话框按钮：取消（灰色）、确认删除（红色）
   - **删除逻辑**：
     - 点击"确认删除"后，从localStorage中删除对应ID的模型
     - 关闭对话框
     - 刷新列表（被删除的卡片消失）
     - 显示Toast："删除成功"
   - **取消逻辑**：
     - 点击"取消"或对话框外部，关闭对话框，不执行删除

3. **Modal组件扩展**：
   - 添加mode属性：'create' | 'edit'
   - 添加modelId属性：编辑模式时传入模型ID
   - 根据mode显示不同的标题和按钮文字
   - 编辑模式下，组件挂载时从localStorage读取数据并预填充

4. **数据更新格式**（localStorage）：
   ```json
   {
     "id": "1708234567890",
     "name": "OpenAI GPT-4o (Updated)",
     "provider": "OpenAI",
     "version": "gpt-4o-2024-08-06",
     "apiKey": "sk-new-key-***",
     "timeout": 90,
     "updatedAt": "2024-02-17T15:30:00Z",
     "createdAt": "2024-02-17T10:30:00Z"
   }
   ```

5. **错误处理**：
   - 编辑时，如果模型ID不存在，显示错误Toast："模型不存在"
   - 删除时，如果模型ID不存在，显示错误Toast："模型不存在"
   - localStorage操作失败时，显示错误Toast："操作失败，请重试"

**技术约束**：
- 编辑和创建共用同一个Modal组件，通过mode属性区分
- 删除确认对话框可使用window.confirm或自定义Modal
- 删除操作必须有二次确认，防止误删

**验收方案**：
- [ ] 功能验收：编辑保存后数据更新（localStorage和列表），删除后卡片消失（localStorage和列表）
- [ ] 交互验收：编辑Modal预填充正确（所有字段），删除有确认对话框，取消可关闭对话框
- [ ] 视觉验收：编辑和删除操作流畅，无视觉闪烁，删除按钮为红色，确认对话框样式清晰

---

### Phase 3: 提示词编辑器升级（2天）

#### 任务3.1: 集成Monaco Editor

**📋 实现功能**：M2.1.1（Monaco Editor集成）

**🎨 本次可见产出**：
- Prompt页面中间的编辑区从简单文本框变成Monaco Editor
- 编辑器有行号、语法高亮（Markdown）
- 编辑器可正常输入、编辑、复制、粘贴

**实现目标**：
在 `pages/Prompt.tsx` 中，将编辑区替换为Monaco Editor组件

**功能详细说明**：
1. **安装依赖**：
   ```bash
   npm install @monaco-editor/react
   ```

2. **编辑器配置**：
   - **语言模式**：markdown（支持Markdown语法高亮）
   - **主题**：vs（浅色主题，与整体风格协调）
   - **字体**：Consolas, 'Courier New', monospace（等宽字体）
   - **字体大小**：14px
   - **行号**：显示（lineNumbers: 'on'）
   - **自动换行**：启用（wordWrap: 'on'）
   - **滚动条**：显示（scrollbar: { vertical: 'visible', horizontal: 'visible' }）
   - **最小高度**：400px

3. **编辑器集成位置**：
   - 在Prompt页面的中间编辑区域
   - 替换现有的textarea或简单文本框
   - 编辑器占据中间区域的全部高度

4. **基本功能**：
   - **输入编辑**：支持正常的文本输入和编辑
   - **快捷键支持**：
     - Ctrl+S：保存（需自定义处理）
     - Ctrl+Z：撤销
     - Ctrl+Y：重做
     - Ctrl+C：复制
     - Ctrl+V：粘贴
     - Ctrl+X：剪切
     - Ctrl+A：全选
     - Ctrl+F：查找
   - **语法高亮**：Markdown语法自动高亮（标题、列表、代码块等）

5. **组件实现示例**：
   ```tsx
   import Editor from '@monaco-editor/react';

   <Editor
     height="400px"
     defaultLanguage="markdown"
     theme="vs"
     value={promptContent}
     onChange={(value) => setPromptContent(value || '')}
     options={{
       fontSize: 14,
       lineNumbers: 'on',
       wordWrap: 'on',
       minimap: { enabled: false },
       scrollbar: {
         vertical: 'visible',
         horizontal: 'visible'
       }
     }}
   />
   ```

6. **状态管理**：
   - 使用React useState管理编辑器内容
   - 内容变化时触发onChange回调
   - 保存编辑器内容到组件状态

**技术约束**：
- 必须使用 `@monaco-editor/react` 包（版本 ^4.6.0）
- 编辑器语言设置为 `markdown`
- 编辑器主题使用 `vs`（浅色主题）
- 禁用minimap（代码缩略图），节省空间

**验收方案**：
- [ ] 功能验收：Monaco Editor正确渲染，可输入编辑，内容实时同步到状态
- [ ] 交互验收：编辑器支持快捷键（Ctrl+S、Ctrl+Z、Ctrl+C、Ctrl+V），Markdown语法高亮正常
- [ ] 视觉验收：编辑器主题与整体风格协调，字体为等宽字体，行号清晰可见

#### 任务3.2: 实现变量高亮

**📋 实现功能**：M2.1.2（变量高亮）

**🎨 本次可见产出**：
- 编辑器中的 `{{variable}}` 格式文本有特殊高亮（蓝色背景或蓝色文字）
- 高亮效果清晰可见，易于识别变量位置

**实现目标**：
配置Monaco Editor的自定义语法高亮规则

**功能详细说明**：
1. **变量格式定义**：
   - 变量格式：`{{variableName}}`
   - 变量名规则：字母、数字、下划线组成，如 `{{user_name}}`、`{{age}}`
   - 正则表达式：`\{\{[a-zA-Z_][a-zA-Z0-9_]*\}\}`

2. **高亮样式规格**：
   - **文字颜色**：品牌色（#3b82f6，blue-600）
   - **背景颜色**：浅蓝色（#dbeafe，blue-50）
   - **字体粗细**：加粗（font-weight: 600）
   - **效果**：变量文本在编辑器中明显区别于普通文本

3. **Monaco语法配置**：
   使用 `monaco.languages.setMonarchTokensProvider` 配置自定义语法规则：

   ```typescript
   import * as monaco from 'monaco-editor';

   // 注册自定义语言（基于markdown扩展）
   monaco.languages.register({ id: 'prompt-template' });

   // 配置语法高亮规则
   monaco.languages.setMonarchTokensProvider('prompt-template', {
     tokenizer: {
       root: [
         // 变量高亮规则
         [/\{\{[a-zA-Z_][a-zA-Z0-9_]*\}\}/, 'variable'],
         // 继承markdown的其他规则
         { include: '@markdown' }
       ],
       markdown: [
         // Markdown语法规则（标题、列表等）
       ]
     }
   });

   // 定义变量的样式
   monaco.editor.defineTheme('prompt-theme', {
     base: 'vs',
     inherit: true,
     rules: [
       { token: 'variable', foreground: '3b82f6', fontStyle: 'bold', background: 'dbeafe' }
     ],
     colors: {}
   });
   ```

4. **编辑器配置更新**：
   - 将编辑器语言从 `markdown` 改为 `prompt-template`
   - 将编辑器主题从 `vs` 改为 `prompt-theme`
   - 保持其他配置不变

5. **实时高亮**：
   - 用户输入 `{{` 时，编辑器自动识别
   - 输入完整的 `{{name}}` 后，立即应用高亮样式
   - 删除或修改变量时，高亮实时更新

**技术约束**：
- 使用Monaco的 `monaco.languages.setMonarchTokensProvider` 配置语法
- 变量高亮颜色使用品牌色（#3b82f6）
- 高亮配置在组件挂载时执行一次

**验收方案**：
- [ ] 功能验收：`{{variable}}` 格式文本有特殊高亮，颜色为蓝色
- [ ] 交互验收：输入变量时实时高亮，删除变量时高亮消失
- [ ] 视觉验收：高亮颜色与品牌色协调，易于识别，不影响阅读

#### 任务3.3: 自动提取变量到测试面板

**📋 实现功能**：M2.1.3（自动提取变量）

**🎨 本次可见产出**：
- 编辑器中输入 `{{name}}` 后，右侧测试面板的"变量输入"区域自动出现 `name` 输入框
- 删除 `{{name}}` 后，对应输入框消失
- 变量输入框可填写测试值

**实现目标**：
在 `pages/Prompt.tsx` 中，监听编辑器内容变化，提取变量并更新测试面板

**功能详细说明**：
1. **变量提取逻辑**：
   - 监听Monaco Editor的onChange事件
   - 使用正则表达式提取所有变量：`/\{\{(\w+)\}\}/g`
   - 提取结果去重（同一变量只显示一个输入框）
   - 按变量首次出现顺序排序

   ```typescript
   const extractVariables = (content: string): string[] => {
     const regex = /\{\{(\w+)\}\}/g;
     const matches = content.matchAll(regex);
     const variables = Array.from(matches, m => m[1]);
     return Array.from(new Set(variables)); // 去重
   };
   ```

2. **防抖处理**：
   - 使用防抖函数，延迟500ms执行提取
   - 避免用户输入时频繁触发提取
   - 使用lodash.debounce或自定义防抖函数

   ```typescript
   import { debounce } from 'lodash';

   const debouncedExtract = debounce((content: string) => {
     const vars = extractVariables(content);
     setVariables(vars);
   }, 500);
   ```

3. **测试面板更新**：
   - 右侧测试面板的"变量输入"区域动态渲染输入框
   - 每个变量对应一个输入框：
     - 标签：变量名（如"name"）
     - 输入框：文本输入框，placeholder "请输入 {变量名}"
     - 样式：与现有输入框一致
   - 变量列表变化时，输入框列表自动更新

4. **变量值管理**：
   - 使用对象存储变量值：`{ [variableName: string]: string }`
   - 用户在输入框中输入值时，更新对应变量的值
   - 变量被删除时，保留其值（用户可能重新添加）

   ```typescript
   const [variableValues, setVariableValues] = useState<Record<string, string>>({});

   const handleVariableChange = (varName: string, value: string) => {
     setVariableValues(prev => ({ ...prev, [varName]: value }));
   };
   ```

5. **测试面板UI结构**：
   ```tsx
   <div className="space-y-3">
     <h4 className="text-sm font-medium text-gray-700">变量输入</h4>
     {variables.length === 0 ? (
       <p className="text-sm text-gray-400">暂无变量</p>
     ) : (
       variables.map(varName => (
         <div key={varName}>
           <label className="block text-sm text-gray-600 mb-1">{varName}</label>
           <input
             type="text"
             placeholder={`请输入 ${varName}`}
             value={variableValues[varName] || ''}
             onChange={(e) => handleVariableChange(varName, e.target.value)}
             className="w-full px-3 py-2 border border-gray-300 rounded"
           />
         </div>
       ))
     )}
   </div>
   ```

6. **边界情况处理**：
   - 编辑器内容为空：显示"暂无变量"
   - 变量格式错误（如`{{}`、`{{ name }}`）：不提取
   - 变量名重复：只显示一个输入框
   - 变量被删除后重新添加：恢复之前输入的值

**技术约束**：
- 使用正则表达式 `/\{\{(\w+)\}\}/g` 提取变量
- 变量提取有防抖处理（500ms）
- 变量值使用React useState管理

**验收方案**：
- [ ] 功能验收：编辑器变量变化时，测试面板自动更新，变量列表正确
- [ ] 交互验收：变量提取有防抖（500ms），不会频繁更新，输入框可正常输入
- [ ] 视觉验收：新增的变量输入框样式与现有一致，无变量时显示"暂无变量"提示

---

### Phase 4: 提示词测试功能（2天）

#### 任务4.1: 实现模型选择和测试触发

**📋 实现功能**：M2.2.1（模型选择）、M2.2.2（变量输入）、M2.2.3（参数配置）

**🎨 本次可见产出**：
- 右侧测试面板的"模型"下拉框显示所有可用模型（从Phase 1的模型列表获取）
- 填写变量值后，点击"执行测试"按钮，按钮变为Loading状态
- 测试结果区域显示"正在执行..."提示

**实现目标**：
在 `pages/Prompt.tsx` 中，实现模型选择和测试触发逻辑

**功能详细说明**：
1. **模型选择下拉框**：
   - **位置**：右侧测试面板顶部
   - **数据源**：从localStorage读取模型列表（key: "models"）
   - **显示内容**：模型名称 + 提供商，如"OpenAI GPT-4o (OpenAI)"
   - **默认选择**：第一个状态为"normal"的模型
   - **过滤规则**：只显示状态为"normal"的模型（不显示error或maintenance状态）
   - **样式**：下拉框宽度100%，高度40px，边框灰色

2. **参数配置区域**（可选，可折叠）：
   - **Temperature**：滑块，范围0-2，步长0.1，默认0.7
   - **Max Tokens**：数字输入框，范围100-128000，默认4096
   - **Top P**：滑块，范围0-1，步长0.1，默认1
   - **折叠状态**：默认折叠，点击"高级参数"展开

3. **执行测试按钮**：
   - **位置**：测试面板底部
   - **文字**：默认"执行测试"，执行中"执行中..."
   - **图标**：默认播放图标，执行中旋转加载图标
   - **样式**：品牌色背景，白色文字，宽度100%，高度40px
   - **禁用条件**：
     - 未选择模型
     - 必填变量未填写
     - 正在执行中
   - **禁用样式**：灰色背景，不可点击

4. **测试触发逻辑**：
   - 点击"执行测试"按钮
   - 验证必填项：模型已选择，必填变量已填写
   - 验证失败：显示错误Toast，如"请填写所有必填变量"
   - 验证成功：
     - 按钮变为Loading状态
     - 测试结果区域显示"正在执行..."
     - 构造测试请求数据
     - 调用Mock API（下一任务实现真实SSE）

5. **测试请求数据结构**：
   ```typescript
   interface TestRequest {
     modelId: string;           // 选中的模型ID
     promptContent: string;     // 提示词内容（变量已替换）
     variables: Record<string, string>;  // 变量值
     parameters: {
       temperature: number;
       maxTokens: number;
       topP: number;
     };
   }
   ```

6. **变量替换逻辑**：
   - 将提示词内容中的 `{{variableName}}` 替换为用户输入的值
   - 替换前验证所有变量都有值
   - 替换后的内容作为实际发送给LLM的提示词

   ```typescript
   const replaceVariables = (content: string, values: Record<string, string>): string => {
     return content.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
       return values[varName] || match;
     });
   };
   ```

**技术约束**：
- 模型列表从localStorage获取（key: "models"）
- 测试触发时调用Mock API（暂不实现真实SSE）
- 参数配置使用React useState管理

**验收方案**：
- [ ] 功能验收：模型下拉框显示所有可用模型（status='normal'），点击测试按钮触发请求，变量正确替换
- [ ] 交互验收：测试执行中按钮显示Loading，禁用点击，必填项未填写时按钮禁用
- [ ] 视觉验收：Loading状态有旋转图标，按钮样式符合规格

#### 任务4.2: 实现流式响应展示（SSE）

**📋 实现功能**：M2.2.4（执行测试）、M2.2.5（流式响应展示）、M2.2.6（测试结果操作）

**🎨 本次可见产出**：
- 点击"执行测试"后，测试结果区域逐字显示响应内容（打字机效果）
- 响应完成后显示"执行完成"提示
- 显示耗时（如"耗时: 2.3s"）和Token统计（如"Token: 380"）

**实现目标**：
在 `pages/Prompt.tsx` 中，实现SSE流式响应展示

**功能详细说明**：
1. **Mock SSE实现**（Phase 1暂用Mock，后续对接真实API）：
   - 模拟流式响应：将完整响应文本按字符分割，逐字返回
   - 每个字符延迟50ms，模拟真实流式效果
   - Mock响应示例文本：
     ```
     根据您提供的信息，我对该人物进行以下心理分析：

     1. 性格特征：该人物表现出较强的责任心和执行力...
     2. 情绪状态：整体情绪稳定，但在压力情境下可能出现焦虑...
     3. 行为模式：倾向于理性思考，决策时会综合考虑多方面因素...
     ```

2. **流式响应处理**：
   ```typescript
   const mockStreamResponse = async (
     prompt: string,
     onChunk: (chunk: string) => void,
     onComplete: (stats: { duration: number; tokens: number }) => void
   ) => {
     const startTime = Date.now();
     const mockResponse = "根据您提供的信息，我对该人物进行以下心理分析：\n\n1. 性格特征...";

     for (let i = 0; i < mockResponse.length; i++) {
       await new Promise(resolve => setTimeout(resolve, 50));
       onChunk(mockResponse[i]);
     }

     const duration = (Date.now() - startTime) / 1000;
     const tokens = Math.floor(mockResponse.length / 4); // 粗略估算
     onComplete({ duration, tokens });
   };
   ```

3. **测试结果区域UI**：
   - **位置**：右侧测试面板，"执行测试"按钮下方
   - **布局**：
     - 顶部：状态标签（执行中/已完成/失败）
     - 中间：响应内容区域（白色背景，灰色边框，圆角，padding）
     - 底部：统计信息（耗时、Token数）
   - **响应内容样式**：
     - 字体：14px，行高1.6
     - 颜色：深灰色（#374151）
     - 最大高度：400px，超出滚动
     - Markdown渲染：支持换行、列表等基本格式

4. **打字机效果实现**：
   ```typescript
   const [responseText, setResponseText] = useState('');
   const [isStreaming, setIsStreaming] = useState(false);

   const handleTest = async () => {
     setIsStreaming(true);
     setResponseText('');

     await mockStreamResponse(
       replacedPrompt,
       (chunk) => {
         setResponseText(prev => prev + chunk);
       },
       (stats) => {
         setIsStreaming(false);
         setTestStats(stats);
       }
     );
   };
   ```

5. **状态显示**：
   - **执行中**：
     - 状态标签：蓝色背景，"执行中"文字，旋转加载图标
     - 响应内容：逐字显示，光标闪烁效果
   - **已完成**：
     - 状态标签：绿色背景，"已完成"文字，勾选图标
     - 统计信息：显示耗时和Token数
     - 示例："耗时: 2.3s | Token: 380"
   - **失败**：
     - 状态标签：红色背景，"失败"文字，错误图标
     - 错误信息：红色文字显示错误原因

6. **停止功能**（可选）：
   - 执行中显示"停止"按钮
   - 点击停止按钮，中断流式响应
   - 显示已接收的部分内容
   - 状态标签变为"已中断"

7. **统计信息计算**：
   - **耗时**：从开始执行到完成的时间差（秒）
   - **Token数**：粗略估算 = 字符数 / 4（中文）或字符数 / 5（英文）
   - **显示格式**：保留1位小数，如"2.3s"、"380 tokens"

**技术约束**：
- 使用Mock模拟流式响应（每字符延迟50ms）
- 流式响应有打字机效果（逐字显示）
- 响应内容使用React useState管理

**验收方案**：
- [ ] 功能验收：响应内容逐字显示（50ms/字符），完成后显示耗时和Token统计，统计数据准确
- [ ] 交互验收：响应过程中可点击"停止"按钮中断（可选），中断后显示部分内容
- [ ] 视觉验收：打字机效果流畅，耗时和Token统计显示在结果下方，状态标签颜色正确

#### 任务4.3: 实现测试结果操作

**📋 实现功能**：M2.2.6（测试结果操作）、M2.2.7（错误处理）

**🎨 本次可见产出**：
- 测试结果区域右上角有"复制"按钮
- 点击复制按钮，结果内容复制到剪贴板，显示"已复制"Toast
- 测试失败时，结果区域显示红色错误信息

**实现目标**：
在 `pages/Prompt.tsx` 中，添加测试结果操作功能

**功能详细说明**：
1. **复制按钮**：
   - **位置**：测试结果区域右上角
   - **图标**：复制图标（Lucide React的Copy图标）
   - **样式**：灰色图标，hover时变为品牌色
   - **显示条件**：只在有响应内容时显示
   - **点击行为**：
     - 复制响应内容到剪贴板
     - 显示Toast提示："已复制"
     - 按钮图标短暂变为勾选图标（1秒后恢复）

2. **复制功能实现**：
   ```typescript
   const handleCopy = async () => {
     try {
       await navigator.clipboard.writeText(responseText);
       setShowCopySuccess(true);
       setTimeout(() => setShowCopySuccess(false), 1000);
       // 显示Toast
       toast.success('已复制');
     } catch (error) {
       toast.error('复制失败');
     }
   };
   ```

3. **错误处理**：
   - **错误类型**：
     - 网络错误：无法连接到API
     - 模型错误：模型返回错误（API Key无效、配额不足等）
     - 超时错误：请求超时（超过60秒）
     - 验证错误：必填变量未填写

   - **错误显示**：
     - 状态标签：红色背景，"失败"文字，错误图标
     - 错误信息：红色文字，显示具体错误原因
     - 错误信息示例：
       - "网络错误：无法连接到服务器"
       - "模型错误：API Key无效"
       - "超时错误：请求超时，请重试"
       - "验证错误：请填写所有必填变量"

4. **错误处理逻辑**：
   ```typescript
   const handleTest = async () => {
     try {
       // 验证必填项
       const missingVars = variables.filter(v => !variableValues[v]);
       if (missingVars.length > 0) {
         setError(`请填写变量：${missingVars.join(', ')}`);
         return;
       }

       setIsStreaming(true);
       setError(null);
       setResponseText('');

       await mockStreamResponse(
         replacedPrompt,
         (chunk) => setResponseText(prev => prev + chunk),
         (stats) => {
           setIsStreaming(false);
           setTestStats(stats);
         }
       );
     } catch (error) {
       setIsStreaming(false);
       setError(error.message || '测试失败，请重试');
     }
   };
   ```

5. **重试功能**：
   - 测试失败时，显示"重试"按钮
   - 点击重试按钮，清空错误信息，重新执行测试
   - 重试按钮样式：品牌色边框，品牌色文字

6. **测试结果区域完整UI结构**：
   ```tsx
   <div className="mt-4 border border-gray-200 rounded-lg p-4">
     {/* 顶部：状态标签和操作按钮 */}
     <div className="flex items-center justify-between mb-2">
       <div className="flex items-center space-x-2">
         {isStreaming && (
           <span className="px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded">
             执行中
           </span>
         )}
         {!isStreaming && responseText && !error && (
           <span className="px-2 py-1 bg-green-100 text-green-700 text-xs rounded">
             已完成
           </span>
         )}
         {error && (
           <span className="px-2 py-1 bg-red-100 text-red-700 text-xs rounded">
             失败
           </span>
         )}
       </div>
       {responseText && !error && (
         <button onClick={handleCopy} className="text-gray-500 hover:text-brand-600">
           {showCopySuccess ? <Check size={16} /> : <Copy size={16} />}
         </button>
       )}
     </div>

     {/* 中间：响应内容或错误信息 */}
     {error ? (
       <div className="text-red-600 text-sm">{error}</div>
     ) : (
       <div className="text-gray-700 text-sm whitespace-pre-wrap max-h-96 overflow-y-auto">
         {responseText || '等待执行...'}
       </div>
     )}

     {/* 底部：统计信息或重试按钮 */}
     {!isStreaming && testStats && !error && (
       <div className="mt-2 text-xs text-gray-500">
         耗时: {testStats.duration}s | Token: {testStats.tokens}
       </div>
     )}
     {error && (
       <button
         onClick={handleTest}
         className="mt-2 px-3 py-1 border border-brand-600 text-brand-600 rounded text-sm hover:bg-brand-50"
       >
         重试
       </button>
     )}
   </div>
   ```

**技术约束**：
- 使用 `navigator.clipboard.writeText` 实现复制
- 错误信息显示在结果区域，红色文字
- Toast提示使用react-hot-toast或自定义实现

**验收方案**：
- [ ] 功能验收：复制按钮可复制结果到剪贴板，错误信息正确显示（4种错误类型），重试按钮可重新执行测试
- [ ] 交互验收：复制成功显示Toast提示，复制按钮图标短暂变为勾选，重试按钮点击后清空错误
- [ ] 视觉验收：错误信息为红色，易于识别，复制按钮hover效果明显，重试按钮样式符合规格

---

### Phase 5: 本体图谱可视化（2天）

#### 任务5.1: 集成G6图谱库

**📋 实现功能**：M3.2.1（G6图谱集成）、M3.2.2（节点展示）、M3.2.3（边展示）、M3.2.8（布局算法）

**🎨 本次可见产出**：
- Ontology页面的"本体关系图"Tab中，占位符被G6画布替换
- 画布中显示3-5个示例节点（圆形+图标+标签）
- 节点之间有连线（箭头）

**实现目标**：
在 `pages/Ontology.tsx` 中，集成@antv/g6并渲染示例图谱

**功能详细说明**：
1. **安装依赖**：
   ```bash
   npm install @antv/g6@4.8.24
   ```
   注意：必须使用4.8.x版本，不使用5.x版本

2. **画布配置**：
   - **容器**：在"本体关系图"Tab中创建div容器，id="ontology-graph-container"
   - **尺寸**：宽度100%，高度600px
   - **背景**：浅灰色网格背景
   - **模式**：默认模式（default），支持拖拽画布、缩放

3. **G6实例初始化**：
   ```typescript
   import G6 from '@antv/g6';

   const graph = new G6.Graph({
     container: 'ontology-graph-container',
     width: containerWidth,
     height: 600,
     modes: {
       default: ['drag-canvas', 'zoom-canvas']
     },
     layout: {
       type: 'force',
       preventOverlap: true,
       nodeSpacing: 100
     },
     defaultNode: {
       type: 'circle',
       size: 60,
       style: {
         fill: '#5B8FF9',
         stroke: '#5B8FF9',
         lineWidth: 2
       },
       labelCfg: {
         position: 'bottom',
         offset: 10,
         style: {
           fontSize: 12,
           fill: '#000'
         }
       }
     },
     defaultEdge: {
       type: 'line',
       style: {
         stroke: '#e2e2e2',
         lineWidth: 2,
         endArrow: {
           path: G6.Arrow.triangle(10, 12, 0),
           fill: '#e2e2e2'
         }
       },
       labelCfg: {
         autoRotate: true,
         style: {
           fontSize: 10,
           fill: '#666'
         }
       }
     }
   });
   ```

4. **节点样式规格**（M3.2.2）：
   - **形状**：圆角矩形（roundedRect）或圆形（circle）
   - **大小**：60px直径
   - **颜色**：根据本体类型区分
     - Entity（实体）：蓝色（#5B8FF9）
     - Event（事件）：绿色（#5AD8A6）
     - State（状态）：橙色（#F6BD16）
     - Attribute（属性）：紫色（#9270CA）
   - **标签**：节点下方显示本体名称，字体12px
   - **图标**：节点中心显示类型图标（可选）

5. **边样式规格**（M3.2.3）：
   - **类型**：直线（line）或曲线（quadratic）
   - **颜色**：浅灰色（#e2e2e2）
   - **宽度**：2px
   - **箭头**：终点有三角形箭头，大小10x12px
   - **标签**：边上显示关系类型，字体10px，自动旋转

6. **示例数据**：
   ```typescript
   const mockData = {
     nodes: [
       { id: 'person', label: 'Person', type: 'Entity', color: '#5B8FF9' },
       { id: 'emotion', label: 'Emotion', type: 'State', color: '#F6BD16' },
       { id: 'behavior', label: 'Behavior', type: 'Event', color: '#5AD8A6' },
       { id: 'trait', label: 'Trait', type: 'Attribute', color: '#9270CA' }
     ],
     edges: [
       { source: 'person', target: 'emotion', label: 'has' },
       { source: 'person', target: 'behavior', label: 'performs' },
       { source: 'person', target: 'trait', label: 'exhibits' }
     ]
   };

   graph.data(mockData);
   graph.render();
   ```

7. **布局算法**（M3.2.8）：
   - **算法类型**：力导向布局（force）
   - **参数配置**：
     - preventOverlap: true（防止节点重叠）
     - nodeSpacing: 100（节点间距100px）
     - linkDistance: 150（边长度150px）
   - **效果**：节点自动分布，关系清晰

8. **响应式处理**：
   - 监听容器尺寸变化
   - 窗口resize时重新计算画布尺寸
   - 使用ResizeObserver或window.addEventListener('resize')

**技术约束**：
- 必须使用 `@antv/g6` 4.8.x（不使用5.x）
- 画布背景为浅灰色网格
- 节点使用圆形或圆角矩形，边使用箭头线条
- 布局算法使用力导向布局（force）

**验收方案**：
- [ ] 功能验收：G6画布正确渲染，显示3-5个示例节点和边，布局合理
- [ ] 交互验收：画布可拖拽、缩放（鼠标滚轮）
- [ ] 视觉验收：节点和边样式符合规格，不同类型节点颜色不同，箭头清晰可见

#### 任务5.2: 实现图谱交互

**📋 实现功能**：M3.2.4（工具栏）、M3.2.5（节点交互）、M3.2.6（画布交互）

**🎨 本次可见产出**：
- 点击节点，节点高亮显示（边框加粗或颜色变化）
- 双击节点，弹出节点详情面板（可以是右侧抽屉或Modal）
- 画布左上角有工具栏（选择、拖拽、适应画布按钮）

**实现目标**：
在 `pages/Ontology.tsx` 中，实现G6图谱的交互功能

**功能详细说明**：
1. **工具栏实现**（M3.2.4）：
   - **位置**：画布左上角，绝对定位，悬浮在画布上方
   - **按钮列表**：
     - 选择模式：鼠标图标，点击切换到选择模式
     - 拖拽模式：手掌图标，点击切换到拖拽模式
     - 放大：加号图标，点击放大画布
     - 缩小：减号图标，点击缩小画布
     - 适应画布：全屏图标，点击自动调整视口显示所有节点
   - **样式**：白色背景，灰色边框，圆角，阴影，按钮间距4px
   - **激活状态**：当前模式的按钮高亮显示（品牌色背景）

   ```tsx
   <div className="absolute top-4 left-4 bg-white border border-gray-200 rounded-lg shadow-sm p-2 flex space-x-2">
     <button
       onClick={() => setMode('select')}
       className={`p-2 rounded ${mode === 'select' ? 'bg-brand-100 text-brand-600' : 'text-gray-600 hover:bg-gray-100'}`}
     >
       <MousePointer size={16} />
     </button>
     <button
       onClick={() => setMode('drag')}
       className={`p-2 rounded ${mode === 'drag' ? 'bg-brand-100 text-brand-600' : 'text-gray-600 hover:bg-gray-100'}`}
     >
       <Hand size={16} />
     </button>
     <div className="w-px bg-gray-200" />
     <button onClick={() => graph.zoom(1.2)} className="p-2 rounded text-gray-600 hover:bg-gray-100">
       <ZoomIn size={16} />
     </button>
     <button onClick={() => graph.zoom(0.8)} className="p-2 rounded text-gray-600 hover:bg-gray-100">
       <ZoomOut size={16} />
     </button>
     <button onClick={() => graph.fitView()} className="p-2 rounded text-gray-600 hover:bg-gray-100">
       <Maximize size={16} />
     </button>
   </div>
   ```

2. **节点交互**（M3.2.5）：
   - **单击节点**：
     - 节点高亮：边框加粗（lineWidth: 4），颜色变深
     - 取消其他节点的高亮
     - 触发事件：node:click
   - **双击节点**：
     - 弹出节点详情面板（右侧抽屉或Modal）
     - 显示节点完整信息：名称、类型、描述、属性列表、关系列表
     - 触发事件：node:dblclick
   - **拖拽节点**：
     - 在拖拽模式下，可拖拽节点改变位置
     - 拖拽时节点跟随鼠标移动
     - 释放后节点固定在新位置

   ```typescript
   graph.on('node:click', (evt) => {
     const node = evt.item;
     graph.setItemState(node, 'selected', true);
     // 取消其他节点的选中状态
     graph.getNodes().forEach(n => {
       if (n !== node) {
         graph.clearItemStates(n, 'selected');
       }
     });
   });

   graph.on('node:dblclick', (evt) => {
     const node = evt.item;
     const model = node.getModel();
     setSelectedNode(model);
     setShowNodeDetail(true);
   });
   ```

3. **画布交互**（M3.2.6）：
   - **拖拽画布**：
     - 在选择模式下，按住鼠标左键拖拽画布
     - 画布跟随鼠标移动
   - **缩放画布**：
     - 鼠标滚轮：向上滚动放大，向下滚动缩小
     - 缩放范围：0.5x - 3x
     - 缩放中心：鼠标位置
   - **适应画布**：
     - 点击工具栏的"适应画布"按钮
     - 自动调整视口，显示所有节点
     - 保持适当的边距（padding: 20px）

4. **模式切换**：
   - **选择模式**（default）：
     - 可点击节点选中
     - 可拖拽画布
     - 可缩放画布
   - **拖拽模式**（drag-node）：
     - 可拖拽节点改变位置
     - 可拖拽画布
     - 可缩放画布

   ```typescript
   const setMode = (mode: 'select' | 'drag') => {
     if (mode === 'select') {
       graph.setMode('default');
     } else {
       graph.setMode('drag-node');
     }
     setCurrentMode(mode);
   };
   ```

5. **节点状态样式**：
   ```typescript
   graph.node((node) => {
     return {
       style: {
         fill: node.color,
         stroke: node.color,
         lineWidth: 2
       },
       stateStyles: {
         selected: {
           lineWidth: 4,
           stroke: '#1890ff'
         },
         hover: {
           lineWidth: 3,
           stroke: '#40a9ff'
         }
       }
     };
   });
   ```

6. **节点详情面板**：
   - **触发**：双击节点
   - **位置**：右侧抽屉或居中Modal
   - **内容**：
     - 节点名称（大标题）
     - 节点类型（标签）
     - 节点描述（文本）
     - 属性列表（表格）
     - 关系列表（表格：关系类型、目标节点）
   - **操作**：关闭按钮

**技术约束**：
- 使用G6的事件监听（node:click, node:dblclick）
- 工具栏按钮功能：选择模式、拖拽模式、适应画布
- 模式切换使用graph.setMode()方法

**验收方案**：
- [ ] 功能验收：点击节点高亮，双击节点显示详情，工具栏按钮功能正常（5个按钮）
- [ ] 交互验收：选择和拖拽模式可切换，适应画布可自动调整视口，缩放范围0.5x-3x
- [ ] 视觉验收：高亮效果明显（边框加粗），工具栏样式与整体风格一致，激活按钮有品牌色背景

#### 任务5.3: 加载真实本体数据

**📋 实现功能**：M3.2.7（加载真实数据）

**🎨 本次可见产出**：
- 图谱中显示的节点和边来自Mock数据（不再是硬编码）
- 节点数量增加到10-15个
- 节点类型有不同的颜色和图标（如Entity、Event、State等）

**实现目标**：
在 `pages/Ontology.tsx` 中，从Mock数据加载本体关系图

**功能详细说明**：
1. **Mock数据结构**：
   ```typescript
   interface OntologyNode {
     id: string;              // 本体ID，如"person"
     label: string;           // 本体名称，如"Person"
     type: string;            // 本体类型：Entity/Event/State/Attribute
     description?: string;    // 本体描述
     properties?: Array<{     // 属性列表
       name: string;
       type: string;
       required: boolean;
     }>;
   }

   interface OntologyEdge {
     source: string;          // 源节点ID
     target: string;          // 目标节点ID
     label: string;           // 关系类型，如"has"、"performs"
     relationType?: string;   // 关系类型：one-to-one/one-to-many/many-to-many
   }

   interface OntologyGraphData {
     nodes: OntologyNode[];
     edges: OntologyEdge[];
   }
   ```

2. **Mock数据示例**（10-15个节点）：
   ```typescript
   const mockOntologyData: OntologyGraphData = {
     nodes: [
       // Entity类型（蓝色）
       { id: 'person', label: 'Person', type: 'Entity', description: '人物实体' },
       { id: 'organization', label: 'Organization', type: 'Entity', description: '组织实体' },
       { id: 'location', label: 'Location', type: 'Entity', description: '地点实体' },

       // Event类型（绿色）
       { id: 'behavior', label: 'Behavior', type: 'Event', description: '行为事件' },
       { id: 'interaction', label: 'Interaction', type: 'Event', description: '交互事件' },
       { id: 'decision', label: 'Decision', type: 'Event', description: '决策事件' },

       // State类型（橙色）
       { id: 'emotion', label: 'Emotion', type: 'State', description: '情绪状态' },
       { id: 'cognitive', label: 'Cognitive', type: 'State', description: '认知状态' },
       { id: 'physical', label: 'Physical', type: 'State', description: '生理状态' },

       // Attribute类型（紫色）
       { id: 'trait', label: 'Trait', type: 'Attribute', description: '性格特质' },
       { id: 'skill', label: 'Skill', type: 'Attribute', description: '技能属性' },
       { id: 'value', label: 'Value', type: 'Attribute', description: '价值观' }
     ],
     edges: [
       { source: 'person', target: 'emotion', label: 'has' },
       { source: 'person', target: 'behavior', label: 'performs' },
       { source: 'person', target: 'trait', label: 'exhibits' },
       { source: 'person', target: 'cognitive', label: 'experiences' },
       { source: 'behavior', target: 'emotion', label: 'triggers' },
       { source: 'emotion', target: 'decision', label: 'influences' },
       { source: 'person', target: 'organization', label: 'belongs_to' },
       { source: 'person', target: 'location', label: 'located_at' },
       { source: 'interaction', target: 'behavior', label: 'includes' },
       { source: 'trait', target: 'behavior', label: 'affects' },
       { source: 'skill', target: 'behavior', label: 'enables' },
       { source: 'value', target: 'decision', label: 'guides' }
     ]
   };
   ```

3. **数据加载逻辑**：
   ```typescript
   const loadOntologyData = () => {
     // 从localStorage或Mock数据获取
     const data = localStorage.getItem('ontologyData');
     if (data) {
       return JSON.parse(data);
     }
     // 使用Mock数据
     return mockOntologyData;
   };

   useEffect(() => {
     const data = loadOntologyData();

     // 转换为G6格式
     const g6Data = {
       nodes: data.nodes.map(node => ({
         id: node.id,
         label: node.label,
         type: node.type,
         style: {
           fill: getColorByType(node.type),
           stroke: getColorByType(node.type)
         }
       })),
       edges: data.edges.map(edge => ({
         source: edge.source,
         target: edge.target,
         label: edge.label
       }))
     };

     graph.data(g6Data);
     graph.render();
   }, []);
   ```

4. **类型颜色映射**：
   ```typescript
   const getColorByType = (type: string): string => {
     const colorMap: Record<string, string> = {
       'Entity': '#5B8FF9',      // 蓝色
       'Event': '#5AD8A6',       // 绿色
       'State': '#F6BD16',       // 橙色
       'Attribute': '#9270CA'    // 紫色
     };
     return colorMap[type] || '#5B8FF9';
   };
   ```

5. **节点样式增强**：
   - 根据类型设置不同颜色
   - 节点大小根据连接数动态调整（可选）
   - 节点标签字体大小根据重要性调整（可选）

6. **数据验证**：
   - 验证节点ID唯一性
   - 验证边的source和target存在于节点列表中
   - 验证必填字段（id, label, type）
   - 数据错误时显示错误提示

   ```typescript
   const validateOntologyData = (data: OntologyGraphData): boolean => {
     // 验证节点ID唯一性
     const nodeIds = new Set(data.nodes.map(n => n.id));
     if (nodeIds.size !== data.nodes.length) {
       console.error('节点ID重复');
       return false;
     }

     // 验证边的source和target
     for (const edge of data.edges) {
       if (!nodeIds.has(edge.source) || !nodeIds.has(edge.target)) {
         console.error(`边的节点不存在: ${edge.source} -> ${edge.target}`);
         return false;
       }
     }

     return true;
   };
   ```

7. **数据持久化**：
   - 图谱数据保存到localStorage（key: "ontologyData"）
   - 页面刷新后数据保留
   - 提供"重置为默认数据"功能

**技术约束**：
- Mock数据包含节点（id, name, type, properties）和边（source, target, relation）
- 不同本体类型使用不同颜色（Entity蓝色、Event绿色、State橙色、Attribute紫色）
- 数据从localStorage或Mock数据加载

**验收方案**：
- [ ] 功能验收：图谱数据来自Mock（10-15个节点），节点和边正确渲染，数据验证通过
- [ ] 数据验收：节点包含完整字段（id, label, type），边的source和target正确关联，无数据错误
- [ ] 视觉验收：不同类型节点有不同颜色（4种颜色），易于区分，布局合理

---

### Phase 6: 本体管理功能（2天）

#### 任务6.1: 实现本体列表和分类树

**📋 实现功能**：M3.1.1（分类树展示）、M3.1.2（分类树交互）、M3.1.3（本体列表展示）

**🎨 本次可见产出**：
- Ontology页面"本体定义"Tab的左侧树显示真实的分类数据（不再是硬编码）
- 点击分类可展开/收起子分类
- 点击分类后，右侧显示该分类下的本体列表

**实现目标**：
在 `pages/Ontology.tsx` 中，实现分类树数据加载和本体列表展示

**功能详细说明**：
1. **分类树数据结构**：
   ```typescript
   interface OntologyCategory {
     id: string;              // 分类ID
     name: string;            // 分类名称
     type: string;            // 分类类型：Entity/Event/State/Attribute
     children?: OntologyCategory[];  // 子分类
     ontologies?: string[];   // 该分类下的本体ID列表
   }
   ```

2. **Mock分类树数据**：
   ```typescript
   const mockCategories: OntologyCategory[] = [
     {
       id: 'entity',
       name: 'Entity（实体）',
       type: 'Entity',
       children: [
         { id: 'person', name: 'Person（人物）', type: 'Entity', ontologies: ['person'] },
         { id: 'organization', name: 'Organization（组织）', type: 'Entity', ontologies: ['organization'] },
         { id: 'location', name: 'Location（地点）', type: 'Entity', ontologies: ['location'] }
       ]
     },
     {
       id: 'event',
       name: 'Event（事件）',
       type: 'Event',
       children: [
         { id: 'behavior', name: 'Behavior（行为）', type: 'Event', ontologies: ['behavior'] },
         { id: 'interaction', name: 'Interaction（交互）', type: 'Event', ontologies: ['interaction'] },
         { id: 'decision', name: 'Decision（决策）', type: 'Event', ontologies: ['decision'] }
       ]
     },
     {
       id: 'state',
       name: 'State（状态）',
       type: 'State',
       children: [
         { id: 'emotion', name: 'Emotion（情绪）', type: 'State', ontologies: ['emotion'] },
         { id: 'cognitive', name: 'Cognitive（认知）', type: 'State', ontologies: ['cognitive'] },
         { id: 'physical', name: 'Physical（生理）', type: 'State', ontologies: ['physical'] }
       ]
     },
     {
       id: 'attribute',
       name: 'Attribute（属性）',
       type: 'Attribute',
       children: [
         { id: 'trait', name: 'Trait（特质）', type: 'Attribute', ontologies: ['trait'] },
         { id: 'skill', name: 'Skill（技能）', type: 'Attribute', ontologies: ['skill'] },
         { id: 'value', name: 'Value（价值观）', type: 'Attribute', ontologies: ['value'] }
       ]
     }
   ];
   ```

3. **分类树UI实现**（M3.1.1, M3.1.2）：
   ```tsx
   const CategoryTree: React.FC<{ categories: OntologyCategory[], onSelect: (id: string) => void }> = ({ categories, onSelect }) => {
     const [expanded, setExpanded] = useState<Set<string>>(new Set());
     const [selected, setSelected] = useState<string>('');

     const toggleExpand = (id: string) => {
       const newExpanded = new Set(expanded);
       if (newExpanded.has(id)) {
         newExpanded.delete(id);
       } else {
         newExpanded.add(id);
       }
       setExpanded(newExpanded);
     };

     const handleSelect = (id: string) => {
       setSelected(id);
       onSelect(id);
     };

     return (
       <div className="space-y-1">
         {categories.map(category => (
           <div key={category.id}>
             <div
               className={`flex items-center px-3 py-2 rounded cursor-pointer ${
                 selected === category.id ? 'bg-brand-50 text-brand-700' : 'hover:bg-gray-50'
               }`}
               onClick={() => handleSelect(category.id)}
             >
               {category.children && (
                 <button onClick={(e) => { e.stopPropagation(); toggleExpand(category.id); }}>
                   {expanded.has(category.id) ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
                 </button>
               )}
               <span className="ml-2">{category.name}</span>
             </div>
             {expanded.has(category.id) && category.children && (
               <div className="ml-4">
                 <CategoryTree categories={category.children} onSelect={onSelect} />
               </div>
             )}
           </div>
         ))}
       </div>
     );
   };
   ```

4. **本体列表展示**（M3.1.3）：
   - **触发**：点击分类树节点
   - **数据源**：根据选中分类的ontologies字段，从本体数据中筛选
   - **列表项内容**：
     - 本体名称（大字体）
     - 本体类型标签（颜色编码）
     - 本体描述（灰色小字）
     - 操作按钮：编辑、删除
   - **空状态**：选中分类无本体时显示"该分类下暂无本体"

5. **本体列表UI**：
   ```tsx
   <div className="space-y-2">
     {ontologies.length === 0 ? (
       <div className="text-center text-gray-400 py-8">该分类下暂无本体</div>
     ) : (
       ontologies.map(ontology => (
         <div key={ontology.id} className="border border-gray-200 rounded-lg p-4 hover:shadow-sm">
           <div className="flex items-start justify-between">
             <div>
               <div className="flex items-center space-x-2">
                 <h4 className="font-medium text-gray-800">{ontology.label}</h4>
                 <span className={`px-2 py-0.5 rounded text-xs ${getTypeStyle(ontology.type)}`}>
                   {ontology.type}
                 </span>
               </div>
               <p className="text-sm text-gray-500 mt-1">{ontology.description}</p>
             </div>
             <div className="flex space-x-2">
               <button className="text-gray-600 hover:text-brand-600">
                 <Edit size={16} />
               </button>
               <button className="text-gray-600 hover:text-red-600">
                 <Trash size={16} />
               </button>
             </div>
           </div>
         </div>
       ))
     )}
   </div>
   ```

6. **分类树交互行为**：
   - **展开/收起**：点击箭头图标切换子分类显示
   - **选中高亮**：点击分类节点，背景变为品牌色浅色
   - **递归渲染**：支持多层级分类嵌套
   - **默认状态**：顶级分类默认展开

**技术约束**：
- 使用递归组件实现分类树
- Mock数据包含分类层级（Entity、Event、State、Attribute）
- 分类树状态使用React useState管理

**验收方案**：
- [ ] 功能验收：分类树正确展示层级（4个顶级分类，每个3个子分类），点击分类显示本体列表
- [ ] 交互验收：分类可展开/收起，选中分类有高亮（品牌色背景），递归渲染正常
- [ ] 视觉验收：树形结构清晰，选中状态使用品牌色，空状态提示明显

#### 任务6.2: 实现本体创建和编辑表单

**📋 实现功能**：M3.1.4（基本信息编辑）、M3.1.5（属性定义）、M3.1.7（本体创建）、M3.1.8（本体编辑）

**🎨 本次可见产出**：
- 点击"新建本体"按钮，右侧详情区显示创建表单
- 表单包含：本体名称、类型、描述、属性列表
- 属性列表可动态添加/删除（属性名、属性类型、是否必填）
- 点击"保存"后，左侧列表新增一条记录

**实现目标**：
在 `pages/Ontology.tsx` 中，实现本体创建和编辑表单

**功能详细说明**：
1. **基本信息表单**（M3.1.4）：
   - **本体名称**（必填）：文本输入框，placeholder "如：Person"
   - **本体类型**（必填）：下拉选择，选项：Entity/Event/State/Attribute
   - **所属分类**（必填）：下拉选择，从分类树中选择
   - **本体描述**（可选）：多行文本框，placeholder "描述本体的用途和含义"

2. **属性定义动态表单**（M3.1.5）：
   - **表单结构**：表格形式，每行一个属性
   - **列定义**：
     - 属性名（必填）：文本输入框
     - 属性类型（必填）：下拉选择，选项：string/number/boolean/date/array/object
     - 是否必填：复选框
     - 默认值（可选）：文本输入框
     - 操作：删除按钮
   - **添加属性**：表格底部有"添加属性"按钮
   - **删除属性**：每行右侧有删除按钮（×图标）

   ```tsx
   const [properties, setProperties] = useState<Property[]>([]);

   interface Property {
     id: string;
     name: string;
     type: string;
     required: boolean;
     defaultValue?: string;
   }

   const addProperty = () => {
     setProperties([...properties, {
       id: Date.now().toString(),
       name: '',
       type: 'string',
       required: false
     }]);
   };

   const removeProperty = (id: string) => {
     setProperties(properties.filter(p => p.id !== id));
   };

   const updateProperty = (id: string, field: string, value: any) => {
     setProperties(properties.map(p =>
       p.id === id ? { ...p, [field]: value } : p
     ));
   };
   ```

3. **属性列表UI**：
   ```tsx
   <div className="space-y-2">
     <label className="block text-sm font-medium text-gray-700">属性定义</label>
     <table className="w-full border border-gray-200 rounded">
       <thead className="bg-gray-50">
         <tr>
           <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">属性名</th>
           <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">类型</th>
           <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">必填</th>
           <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">默认值</th>
           <th className="px-3 py-2 text-center text-xs font-medium text-gray-500">操作</th>
         </tr>
       </thead>
       <tbody>
         {properties.map(prop => (
           <tr key={prop.id} className="border-t border-gray-200">
             <td className="px-3 py-2">
               <input
                 type="text"
                 value={prop.name}
                 onChange={(e) => updateProperty(prop.id, 'name', e.target.value)}
                 className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
               />
             </td>
             <td className="px-3 py-2">
               <select
                 value={prop.type}
                 onChange={(e) => updateProperty(prop.id, 'type', e.target.value)}
                 className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
               >
                 <option value="string">string</option>
                 <option value="number">number</option>
                 <option value="boolean">boolean</option>
                 <option value="date">date</option>
                 <option value="array">array</option>
                 <option value="object">object</option>
               </select>
             </td>
             <td className="px-3 py-2 text-center">
               <input
                 type="checkbox"
                 checked={prop.required}
                 onChange={(e) => updateProperty(prop.id, 'required', e.target.checked)}
                 className="rounded"
               />
             </td>
             <td className="px-3 py-2">
               <input
                 type="text"
                 value={prop.defaultValue || ''}
                 onChange={(e) => updateProperty(prop.id, 'defaultValue', e.target.value)}
                 className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
               />
             </td>
             <td className="px-3 py-2 text-center">
               <button onClick={() => removeProperty(prop.id)} className="text-red-600 hover:text-red-800">
                 <X size={16} />
               </button>
             </td>
           </tr>
         ))}
       </tbody>
     </table>
     <button
       onClick={addProperty}
       className="px-3 py-1 border border-gray-300 rounded text-sm text-gray-600 hover:bg-gray-50"
     >
       + 添加属性
     </button>
   </div>
   ```

4. **表单验证规则**：
   - **本体名称**：不能为空，长度2-50字符，不能与已有本体重名
   - **本体类型**：必须选择一个选项
   - **所属分类**：必须选择一个分类
   - **属性名**：不能为空，不能重复
   - **属性类型**：必须选择一个选项

5. **创建本体逻辑**（M3.1.7）：
   ```typescript
   const handleCreate = () => {
     // 验证表单
     if (!ontologyName || !ontologyType || !category) {
       toast.error('请填写所有必填项');
       return;
     }

     // 验证属性名不重复
     const propNames = properties.map(p => p.name);
     if (new Set(propNames).size !== propNames.length) {
       toast.error('属性名不能重复');
       return;
     }

     // 创建本体对象
     const newOntology = {
       id: Date.now().toString(),
       label: ontologyName,
       type: ontologyType,
       category: category,
       description: description,
       properties: properties,
       createdAt: new Date().toISOString()
     };

     // 保存到localStorage
     const ontologies = JSON.parse(localStorage.getItem('ontologies') || '[]');
     ontologies.push(newOntology);
     localStorage.setItem('ontologies', JSON.stringify(ontologies));

     // 刷新列表
     refreshOntologyList();

     // 显示成功提示
     toast.success('创建成功');

     // 清空表单
     resetForm();
   };
   ```

6. **编辑本体逻辑**（M3.1.8）：
   - **触发**：点击本体列表中的"编辑"按钮
   - **预填充**：将选中本体的数据填充到表单中
   - **保存**：更新localStorage中对应ID的本体数据
   - **刷新**：更新列表和关系图

**技术约束**：
- 属性列表使用动态表单（可添加/删除行）
- 表单状态使用React useState管理
- 数据保存到localStorage（key: "ontologies"）

**验收方案**：
- [ ] 功能验收：表单可填写，属性列表可动态操作（添加/删除），保存后列表更新，数据持久化
- [ ] 交互验收：添加/删除属性流畅，表单验证生效（5个验证规则），编辑时预填充正确
- [ ] 视觉验收：表单布局清晰，动态表单操作按钮明显，表格样式整洁

#### 任务6.3: 实现关系定义功能

**📋 实现功能**：M3.1.6（关系定义）

**🎨 本次可见产出**：
- 本体表单中增加"关系定义"区域
- 可添加关系（关系名称、目标本体、关系类型：一对一/一对多/多对多）
- 保存后，关系在本体关系图中显示为连线

**实现目标**：
在 `pages/Ontology.tsx` 中，实现关系定义功能

**功能详细说明**：
1. **关系定义数据结构**：
   ```typescript
   interface OntologyRelation {
     id: string;
     name: string;              // 关系名称，如"has"、"performs"
     targetOntology: string;    // 目标本体ID
     relationType: string;      // 关系类型：one-to-one/one-to-many/many-to-many
     description?: string;      // 关系描述
   }
   ```

2. **关系定义动态表单**：
   - **表单结构**：表格形式，每行一个关系
   - **列定义**：
     - 关系名称（必填）：文本输入框，如"has"、"performs"、"belongs_to"
     - 目标本体（必填）：下拉选择，从已有本体列表中选择
     - 关系类型（必填）：下拉选择，选项：one-to-one/one-to-many/many-to-many
     - 关系描述（可选）：文本输入框
     - 操作：删除按钮
   - **添加关系**：表格底部有"添加关系"按钮
   - **删除关系**：每行右侧有删除按钮（×图标）

3. **关系定义UI**：
   ```tsx
   const [relations, setRelations] = useState<OntologyRelation[]>([]);

   const addRelation = () => {
     setRelations([...relations, {
       id: Date.now().toString(),
       name: '',
       targetOntology: '',
       relationType: 'one-to-one'
     }]);
   };

   const removeRelation = (id: string) => {
     setRelations(relations.filter(r => r.id !== id));
   };

   const updateRelation = (id: string, field: string, value: any) => {
     setRelations(relations.map(r =>
       r.id === id ? { ...r, [field]: value } : r
     ));
   };

   return (
     <div className="space-y-2 mt-4">
       <label className="block text-sm font-medium text-gray-700">关系定义</label>
       <table className="w-full border border-gray-200 rounded">
         <thead className="bg-gray-50">
           <tr>
             <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">关系名称</th>
             <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">目标本体</th>
             <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">关系类型</th>
             <th className="px-3 py-2 text-left text-xs font-medium text-gray-500">描述</th>
             <th className="px-3 py-2 text-center text-xs font-medium text-gray-500">操作</th>
           </tr>
         </thead>
         <tbody>
           {relations.map(rel => (
             <tr key={rel.id} className="border-t border-gray-200">
               <td className="px-3 py-2">
                 <input
                   type="text"
                   value={rel.name}
                   onChange={(e) => updateRelation(rel.id, 'name', e.target.value)}
                   placeholder="如：has"
                   className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
                 />
               </td>
               <td className="px-3 py-2">
                 <select
                   value={rel.targetOntology}
                   onChange={(e) => updateRelation(rel.id, 'targetOntology', e.target.value)}
                   className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
                 >
                   <option value="">请选择</option>
                   {availableOntologies.map(ont => (
                     <option key={ont.id} value={ont.id}>{ont.label}</option>
                   ))}
                 </select>
               </td>
               <td className="px-3 py-2">
                 <select
                   value={rel.relationType}
                   onChange={(e) => updateRelation(rel.id, 'relationType', e.target.value)}
                   className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
                 >
                   <option value="one-to-one">一对一</option>
                   <option value="one-to-many">一对多</option>
                   <option value="many-to-many">多对多</option>
                 </select>
               </td>
               <td className="px-3 py-2">
                 <input
                   type="text"
                   value={rel.description || ''}
                   onChange={(e) => updateRelation(rel.id, 'description', e.target.value)}
                   className="w-full px-2 py-1 border border-gray-300 rounded text-sm"
                 />
               </td>
               <td className="px-3 py-2 text-center">
                 <button onClick={() => removeRelation(rel.id)} className="text-red-600 hover:text-red-800">
                   <X size={16} />
                 </button>
               </td>
             </tr>
           ))}
         </tbody>
       </table>
       <button
         onClick={addRelation}
         className="px-3 py-1 border border-gray-300 rounded text-sm text-gray-600 hover:bg-gray-50"
       >
         + 添加关系
       </button>
     </div>
   );
   ```

4. **目标本体下拉框数据**：
   - 从localStorage读取所有已创建的本体
   - 排除当前正在编辑的本体（避免自引用）
   - 按本体类型分组显示（可选）

5. **关系验证规则**：
   - **关系名称**：不能为空，长度2-50字符
   - **目标本体**：必须选择一个本体
   - **关系类型**：必须选择一个类型
   - **关系不重复**：同一目标本体的同名关系不能重复

6. **保存关系逻辑**：
   ```typescript
   const handleSaveWithRelations = () => {
     // 验证关系
     for (const rel of relations) {
       if (!rel.name || !rel.targetOntology) {
         toast.error('请填写所有关系的必填项');
         return;
       }
     }

     // 创建/更新本体（包含关系）
     const ontologyData = {
       id: ontologyId || Date.now().toString(),
       label: ontologyName,
       type: ontologyType,
       category: category,
       description: description,
       properties: properties,
       relations: relations,
       createdAt: ontologyId ? existingOntology.createdAt : new Date().toISOString(),
       updatedAt: new Date().toISOString()
     };

     // 保存到localStorage
     const ontologies = JSON.parse(localStorage.getItem('ontologies') || '[]');
     if (ontologyId) {
       // 更新
       const index = ontologies.findIndex(o => o.id === ontologyId);
       ontologies[index] = ontologyData;
     } else {
       // 创建
       ontologies.push(ontologyData);
     }
     localStorage.setItem('ontologies', JSON.stringify(ontologies));

     // 更新关系图数据
     updateGraphEdges(ontologyData);

     toast.success('保存成功');
     refreshOntologyList();
   };

   const updateGraphEdges = (ontology: any) => {
     // 将关系转换为图谱边数据
     const newEdges = ontology.relations.map(rel => ({
       source: ontology.id,
       target: rel.targetOntology,
       label: rel.name,
       relationType: rel.relationType
     }));

     // 更新图谱数据
     const graphData = JSON.parse(localStorage.getItem('ontologyData') || '{"nodes":[],"edges":[]}');
     // 移除旧的边
     graphData.edges = graphData.edges.filter(e => e.source !== ontology.id);
     // 添加新的边
     graphData.edges.push(...newEdges);
     localStorage.setItem('ontologyData', JSON.stringify(graphData));
   };
   ```

7. **关系图同步**：
   - 保存本体时，自动更新本体关系图的边数据
   - 删除本体时，自动删除相关的边
   - 关系变化实时反映在关系图中

**技术约束**：
- 关系定义使用动态表单
- 目标本体从已有本体列表中选择
- 关系数据保存到本体对象的relations字段

**验收方案**：
- [ ] 功能验收：可添加/删除关系，保存后关系图更新（边数据正确），目标本体下拉框显示所有可用本体
- [ ] 交互验收：目标本体下拉框显示所有可用本体，关系验证生效（4个验证规则），关系图实时同步
- [ ] 视觉验收：关系定义区域与属性定义区域样式一致，表格布局整洁

---

### Phase 7: 知识图谱画布（3天）

#### 任务7.1: 集成G6画布到Knowledge页面

**📋 实现功能**：M4.1.1（G6画布集成）、M4.1.2（节点展示）、M4.1.3（边展示）

**🎨 本次可见产出**：
- Knowledge页面左侧画布区域，占位符被G6画布替换
- 画布中显示5-10个示例知识节点（不同颜色代表不同本体类型）
- 节点之间有关系连线

**实现目标**：
在 `pages/Knowledge.tsx` 中，集成@antv/g6并渲染示例知识图谱

**功能详细说明**：
1. **画布配置**（与本体图谱类似，但数据不同）：
   - 容器ID: "knowledge-graph-container"
   - 尺寸：宽度100%，高度100%（占满左侧区域）
   - 背景：浅灰色网格
   - 布局：力导向布局（force）

2. **示例知识数据**（5-10个节点）：
   ```typescript
   const mockKnowledgeData = {
     nodes: [
       { id: 'p1', label: '张三', ontologyType: 'Person', properties: { age: 30, gender: '男' } },
       { id: 'e1', label: '焦虑', ontologyType: 'Emotion', properties: { intensity: 'high' } },
       { id: 'b1', label: '回避行为', ontologyType: 'Behavior', properties: { frequency: 'often' } },
       { id: 'o1', label: 'XX公司', ontologyType: 'Organization', properties: { type: '企业' } },
       { id: 't1', label: '完美主义', ontologyType: 'Trait', properties: { level: 'high' } }
     ],
     edges: [
       { source: 'p1', target: 'e1', label: 'has', properties: {} },
       { source: 'p1', target: 'b1', label: 'performs', properties: {} },
       { source: 'p1', target: 'o1', label: 'works_at', properties: {} },
       { source: 'p1', target: 't1', label: 'exhibits', properties: {} },
       { source: 'e1', target: 'b1', label: 'triggers', properties: {} }
     ]
   };
   ```

3. **节点样式**（M4.1.2）：
   - 根据ontologyType映射颜色（与本体类型颜色一致）
   - 节点大小：60px
   - 节点形状：圆角矩形
   - 标签：节点下方显示label

4. **边样式**（M4.1.3）：
   - 曲线（quadratic）
   - 箭头：终点三角形箭头
   - 标签：边上显示关系类型

**技术约束**：
- 必须使用 `@antv/g6` 4.8.x
- 画布背景为浅灰色网格
- 节点颜色与本体类型对应

**验收方案**：
- [ ] 功能验收：G6画布正确渲染，显示5-10个示例节点和边
- [ ] 交互验收：画布可拖拽、缩放、平移
- [ ] 视觉验收：节点颜色与本体类型对应，边有方向箭头

#### 任务7.2: 实现画布工具栏

**📋 实现功能**：M4.1.4（画布工具栏）、M4.1.5（搜索功能）、M4.1.6（缩放控制）

**🎨 本次可见产出**：
- 画布左上角有工具栏（搜索、放大、缩小、适应画布按钮）
- 点击搜索按钮，显示搜索框，可按节点名称搜索并高亮
- 放大/缩小按钮可调整画布缩放级别
- 适应画布按钮可自动调整视口显示所有节点

**实现目标**：
在 `pages/Knowledge.tsx` 中，实现画布工具栏功能

**功能详细说明**：
1. **工具栏布局**：
   - 位置：画布左上角，绝对定位
   - 按钮：搜索、放大、缩小、适应画布
   - 样式：白色背景，灰色边框，圆角，阴影

2. **搜索功能**（M4.1.5）：
   - 点击搜索按钮，显示搜索输入框
   - 输入节点名称，实时搜索并高亮匹配节点
   - 使用G6的findAll方法查找节点
   - 高亮样式：边框加粗，颜色变为品牌色

3. **缩放控制**（M4.1.6）：
   - 放大：graph.zoom(1.2)
   - 缩小：graph.zoom(0.8)
   - 适应画布：graph.fitView()

**技术约束**：
- 工具栏使用绝对定位，悬浮在画布上方
- 搜索功能使用G6的findAll方法

**验收方案**：
- [ ] 功能验收：工具栏按钮功能正常，搜索可高亮节点
- [ ] 交互验收：缩放流畅，适应画布自动调整视口
- [ ] 视觉验收：工具栏样式与Demo现有工具栏一致

#### 任务7.3: 实现节点和边的交互

**📋 实现功能**：M4.1.7（节点交互）、M4.1.8（边交互）、M4.1.9（画布交互）

**🎨 本次可见产出**：
- 点击节点，节点高亮，右侧工具栏的"节点"Tab显示节点详情
- 点击边，边高亮，右侧工具栏的"关系"Tab显示边详情
- 双击节点，展开该节点的相邻节点（如果有）
- 拖拽节点可改变位置

**实现目标**：
在 `pages/Knowledge.tsx` 中，实现节点和边的交互功能

**功能详细说明**：
1. **节点交互**（M4.1.7）：
   - 单击：高亮节点，右侧显示详情（名称、本体类型、属性列表）
   - 双击：展开相邻节点（如果有未显示的相邻节点）
   - 拖拽：改变节点位置

2. **边交互**（M4.1.8）：
   - 单击：高亮边，右侧显示详情（关系类型、源节点、目标节点、属性）

3. **画布交互**（M4.1.9）：
   - 拖拽画布：平移视口
   - 滚轮缩放：缩放画布
   - 框选：Ctrl+拖拽框选多个节点

**技术约束**：
- 使用G6的事件监听（node:click, edge:click, node:dblclick）
- 节点详情显示在右侧工具栏

**验收方案**：
- [ ] 功能验收：点击节点/边显示详情，双击节点展开相邻节点，拖拽节点改变位置
- [ ] 交互验收：高亮效果明显，详情面板实时更新
- [ ] 视觉验收：高亮颜色使用品牌色，详情面板布局清晰

---

### Phase 8: 知识图谱操作（2天）

#### 任务8.1: 实现节点创建功能

**📋 实现功能**：M4.2.1（节点创建表单）、M4.2.2（动态属性字段）、M4.2.3（创建节点）

**🎨 本次可见产出**：
- 右侧工具栏"节点"Tab中，填写节点信息（本体类型、名称、属性）
- 点击"创建节点"按钮，画布中新增一个节点
- 新节点出现在画布中心位置

**实现目标**：
在 `pages/Knowledge.tsx` 中，实现节点创建功能

**功能详细说明**：
1. **节点创建表单**（M4.2.1）：
   - 本体类型：下拉选择，从Phase 6的本体列表获取
   - 节点名称：文本输入框
   - 动态属性：根据本体类型自动生成

2. **动态属性字段**（M4.2.2）：
   - 根据选中的本体类型，从本体定义中读取属性列表
   - 为每个属性生成对应的输入框
   - 必填属性标记红色星号

3. **创建节点逻辑**（M4.2.3）：
   - 验证表单，生成节点数据
   - 调用graph.addItem('node', nodeData)
   - 节点出现在画布中心

**技术约束**：
- 本体类型从Phase 6的本体列表获取
- 属性字段根据选择的本体类型动态生成

**验收方案**：
- [ ] 功能验收：填写表单后创建节点，画布中显示新节点
- [ ] 交互验收：本体类型切换时属性字段动态更新
- [ ] 视觉验收：新节点样式与现有节点一致

#### 任务8.2: 实现关系创建功能

**📋 实现功能**：M4.3.1（关系创建表单）、M4.3.2（多选节点）、M4.3.3（创建关系）

**🎨 本次可见产出**：
- 选中两个节点后，右侧工具栏"关系"Tab显示"创建关系"表单
- 填写关系类型和属性，点击"创建关系"按钮
- 画布中两个节点之间出现新的连线

**实现目标**：
在 `pages/Knowledge.tsx` 中，实现关系创建功能

**功能详细说明**：
1. **多选节点**（M4.3.2）：
   - Ctrl+点击选择多个节点
   - 选中节点高亮显示
   - 最多选择2个节点

2. **关系创建表单**（M4.3.1）：
   - 关系类型：下拉选择，从本体定义中获取可用关系
   - 关系属性：动态生成

3. **创建关系逻辑**（M4.3.3）：
   - 验证已选中2个节点
   - 调用graph.addItem('edge', edgeData)

**技术约束**：
- 关系类型从本体定义中获取
- 支持多选节点（Ctrl+点击）

**验收方案**：
- [ ] 功能验收：选中两个节点后可创建关系，画布中显示新连线
- [ ] 交互验收：多选节点流畅，关系类型下拉框显示可用关系
- [ ] 视觉验收：新连线样式与现有连线一致

#### 任务8.3: 实现节点和边的编辑删除

**📋 实现功能**：M4.2.4（节点详情展示）、M4.2.5（节点编辑）、M4.2.6（节点删除）、M4.3.4（关系详情展示）、M4.3.5（关系编辑）、M4.3.6（关系删除）

**🎨 本次可见产出**：
- 选中节点后，右侧工具栏显示节点详情和"编辑"、"删除"按钮
- 点击"编辑"，表单变为可编辑状态，修改后保存，节点信息更新
- 点击"删除"，显示确认对话框，确认后节点从画布消失
- 边的编辑删除功能类似

**实现目标**：
在 `pages/Knowledge.tsx` 中，实现节点和边的编辑删除功能

**功能详细说明**：
1. **节点详情展示**（M4.2.4）：
   - 点击节点，右侧显示详情（名称、本体类型、属性列表）
   - 显示"编辑"和"删除"按钮

2. **节点编辑**（M4.2.5）：
   - 点击"编辑"，表单变为可编辑状态
   - 修改后点击"保存"，调用graph.updateItem()更新节点

3. **节点删除**（M4.2.6）：
   - 点击"删除"，显示确认对话框
   - 确认后调用graph.removeItem()删除节点
   - 关联的边自动删除

4. **关系编辑删除**（M4.3.4, M4.3.5, M4.3.6）：
   - 类似节点的编辑删除流程

**技术约束**：
- 删除节点时，关联的边也一起删除
- 删除前有二次确认

**验收方案**：
- [ ] 功能验收：编辑保存后节点/边信息更新，删除后从画布消失
- [ ] 交互验收：编辑和删除操作流畅，删除有确认对话框
- [ ] 视觉验收：编辑状态明显，删除操作无视觉闪烁

---

### Phase 9: 状态管理优化（2天）

#### 任务9.1: 引入Zustand全局状态管理

**📋 实现功能**：全局状态管理配置

**🎨 本次可见产出**：
- 页面切换时，之前的选中状态、过滤条件等被保留
- 例如：在Model页面搜索"GPT"，切换到Prompt页面再回来，搜索框仍显示"GPT"

**实现目标**：
创建全局状态管理，使用Zustand管理跨页面状态

**功能详细说明**：
1. **安装依赖**：`npm install zustand`
2. **创建Store**：
   - modelStore: 模型列表、搜索关键词、过滤条件
   - promptStore: 提示词内容、变量值、测试结果
   - ontologyStore: 本体列表、选中分类、图谱数据
   - knowledgeStore: 知识图谱数据、选中节点
3. **使用persist中间件**：状态持久化到localStorage

**技术约束**：
- 安装 `zustand` 包
- 创建 `stores/` 目录，分别创建 modelStore, promptStore, ontologyStore, knowledgeStore

**验收方案**：
- [ ] 功能验收：页面切换时状态保留，刷新页面后状态恢复（使用persist中间件）
- [ ] 代码验收：Store结构清晰，状态和actions分离
- [ ] 性能验收：状态更新不影响页面性能

#### 任务9.2: 引入TanStack Query管理服务端状态

**📋 实现功能**：服务端状态管理配置

**🎨 本次可见产出**：
- API请求有Loading状态显示（骨架屏或Spinner）
- 数据缓存生效，重复请求不会重新发起
- 请求失败时显示错误提示，可点击"重试"按钮

**实现目标**：
使用TanStack Query管理所有API请求和数据缓存

**功能详细说明**：
1. **安装依赖**：`npm install @tanstack/react-query`
2. **配置QueryClient**：
   - staleTime: 5分钟
   - gcTime: 10分钟
   - retry: 3次
3. **使用useQuery和useMutation**：封装API请求

**技术约束**：
- 安装 `@tanstack/react-query` 包
- 配置QueryClient（staleTime=5min, gcTime=10min）

**验收方案**：
- [ ] 功能验收：API请求有Loading和Error状态，数据缓存生效
- [ ] 交互验收：Loading状态显示骨架屏，错误状态可重试
- [ ] 性能验收：缓存命中时不发起请求，页面响应快

---

### Phase 10: 测试与部署（3天）

#### 任务10.1: 编写单元测试

**📋 实现功能**：单元测试配置和测试用例编写

**🎨 本次可见产出**：
- 运行 `npm test` 可执行单元测试
- 测试覆盖率报告显示核心组件和函数的覆盖率
- 测试通过率 ≥ 90%

**实现目标**：
为核心组件和工具函数编写单元测试

**功能详细说明**：
1. **安装测试依赖**：
   ```bash
   npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
   ```

2. **Vitest配置**（vitest.config.ts）：
   ```typescript
   import { defineConfig } from 'vitest/config';
   import react from '@vitejs/plugin-react';

   export default defineConfig({
     plugins: [react()],
     test: {
       globals: true,
       environment: 'jsdom',
       setupFiles: './src/test/setup.ts',
       coverage: {
         provider: 'v8',
         reporter: ['text', 'json', 'html'],
         exclude: ['node_modules/', 'src/test/']
       }
     }
   });
   ```

3. **测试环境配置**（src/test/setup.ts）：
   ```typescript
   import '@testing-library/jest-dom';
   import { cleanup } from '@testing-library/react';
   import { afterEach } from 'vitest';

   afterEach(() => {
     cleanup();
   });
   ```

4. **测试文件结构**：
   ```
   src/
   ├── components/
   │   └── ModelCard.test.tsx
   ├── hooks/
   │   └── useVariableExtractor.test.ts
   └── utils/
       └── variableParser.test.ts
   ```

5. **测试用例示例**：
   - **工具函数测试**（utils/variableParser.test.ts）：
     ```typescript
     import { describe, it, expect } from 'vitest';
     import { extractVariables } from './variableParser';

     describe('extractVariables', () => {
       it('should extract variables from template', () => {
         const template = 'Hello {{name}}, you are {{age}} years old';
         const result = extractVariables(template);
         expect(result).toEqual(['name', 'age']);
       });

       it('should handle empty template', () => {
         expect(extractVariables('')).toEqual([]);
       });

       it('should ignore invalid format', () => {
         const template = 'Hello {{ name }}, {{}}';
         expect(extractVariables(template)).toEqual([]);
       });
     });
     ```

   - **自定义Hooks测试**（hooks/useVariableExtractor.test.ts）：
     ```typescript
     import { renderHook, act } from '@testing-library/react';
     import { describe, it, expect } from 'vitest';
     import { useVariableExtractor } from './useVariableExtractor';

     describe('useVariableExtractor', () => {
       it('should extract variables from content', () => {
         const { result } = renderHook(() => useVariableExtractor());

         act(() => {
           result.current.extractFromContent('Hello {{name}}');
         });

         expect(result.current.variables).toEqual(['name']);
       });
     });
     ```

   - **组件测试**（components/ModelCard.test.tsx）：
     ```typescript
     import { render, screen, fireEvent } from '@testing-library/react';
     import { describe, it, expect, vi } from 'vitest';
     import ModelCard from './ModelCard';

     describe('ModelCard', () => {
       const mockModel = {
         id: '1',
         name: 'GPT-4o',
         provider: 'OpenAI',
         status: 'normal'
       };

       it('should render model information', () => {
         render(<ModelCard model={mockModel} />);
         expect(screen.getByText('GPT-4o')).toBeInTheDocument();
         expect(screen.getByText('OpenAI')).toBeInTheDocument();
       });

       it('should call onTest when test button clicked', () => {
         const onTest = vi.fn();
         render(<ModelCard model={mockModel} onTest={onTest} />);

         fireEvent.click(screen.getByText('测试连接'));
         expect(onTest).toHaveBeenCalledWith(mockModel.id);
       });
     });
     ```

6. **测试覆盖目标**：
   - 工具函数：100%覆盖
   - 自定义Hooks：≥ 80%覆盖
   - 关键组件：≥ 70%覆盖
   - 总体覆盖率：≥ 70%

7. **测试命令**（package.json）：
   ```json
   {
     "scripts": {
       "test": "vitest",
       "test:ui": "vitest --ui",
       "test:coverage": "vitest --coverage"
     }
   }
   ```

**技术约束**：
- 使用Vitest + Testing Library
- 测试覆盖：工具函数、自定义Hooks、关键组件
- 测试文件命名：*.test.ts 或 *.test.tsx
- 测试文件位置：与被测试文件同目录

**验收方案**：
- [ ] 功能验收：测试可运行，覆盖率 ≥ 70%，测试通过率 ≥ 90%
- [ ] 代码验收：测试用例清晰，易于维护，遵循AAA模式（Arrange-Act-Assert）
- [ ] 文档验收：测试命令和覆盖率报告文档化，README中包含测试说明

#### 任务10.2: 编写E2E测试

**📋 实现功能**：E2E测试配置和核心流程测试用例编写

**🎨 本次可见产出**：
- 运行 `npm run test:e2e` 可执行E2E测试
- 测试覆盖核心用户流程（创建模型、测试提示词、创建本体、创建知识节点）
- 测试通过率 100%

**实现目标**：
使用Playwright编写E2E测试

**功能详细说明**：
1. **安装Playwright**：
   ```bash
   npm install -D @playwright/test
   npx playwright install
   ```

2. **Playwright配置**（playwright.config.ts）：
   ```typescript
   import { defineConfig, devices } from '@playwright/test';

   export default defineConfig({
     testDir: './e2e',
     fullyParallel: true,
     forbidOnly: !!process.env.CI,
     retries: process.env.CI ? 2 : 0,
     workers: process.env.CI ? 1 : undefined,
     reporter: 'html',
     use: {
       baseURL: 'http://localhost:5173',
       trace: 'on-first-retry',
       screenshot: 'only-on-failure'
     },
     projects: [
       {
         name: 'chromium',
         use: { ...devices['Desktop Chrome'] }
       }
     ],
     webServer: {
       command: 'npm run dev',
       url: 'http://localhost:5173',
       reuseExistingServer: !process.env.CI
     }
   });
   ```

3. **测试文件结构**：
   ```
   e2e/
   ├── model-management.spec.ts
   ├── prompt-management.spec.ts
   ├── ontology-management.spec.ts
   └── knowledge-graph.spec.ts
   ```

4. **核心流程测试用例**：
   - **模型管理流程**（e2e/model-management.spec.ts）：
     ```typescript
     import { test, expect } from '@playwright/test';

     test.describe('Model Management', () => {
       test('should create and configure a model', async ({ page }) => {
         await page.goto('/');
         await page.click('text=模型管理');

         // 点击添加模型按钮
         await page.click('button:has-text("添加模型")');

         // 填写模型信息
         await page.fill('input[name="name"]', 'Test GPT-4');
         await page.fill('input[name="apiKey"]', 'sk-test-key');
         await page.selectOption('select[name="provider"]', 'OpenAI');

         // 保存模型
         await page.click('button:has-text("保存")');

         // 验证模型卡片出现
         await expect(page.locator('text=Test GPT-4')).toBeVisible();
       });

       test('should test model connection', async ({ page }) => {
         await page.goto('/');
         await page.click('text=模型管理');

         // 点击测试连接按钮
         await page.click('button:has-text("测试连接")').first();

         // 验证测试结果
         await expect(page.locator('text=连接成功')).toBeVisible({ timeout: 10000 });
       });
     });
     ```

   - **提示词管理流程**（e2e/prompt-management.spec.ts）：
     ```typescript
     import { test, expect } from '@playwright/test';

     test.describe('Prompt Management', () => {
       test('should create and test a prompt', async ({ page }) => {
         await page.goto('/');
         await page.click('text=提示词管理');

         // 在编辑器中输入提示词
         await page.click('.monaco-editor');
         await page.keyboard.type('Hello {{name}}, you are {{age}} years old');

         // 验证变量提取
         await expect(page.locator('text=name')).toBeVisible();
         await expect(page.locator('text=age')).toBeVisible();

         // 填写变量值
         await page.fill('input[placeholder*="name"]', 'Alice');
         await page.fill('input[placeholder*="age"]', '25');

         // 选择模型
         await page.selectOption('select', { index: 0 });

         // 执行测试
         await page.click('button:has-text("执行测试")');

         // 验证测试结果
         await expect(page.locator('text=Hello Alice')).toBeVisible({ timeout: 15000 });
       });
     });
     ```

   - **本体管理流程**（e2e/ontology-management.spec.ts）：
     ```typescript
     import { test, expect } from '@playwright/test';

     test.describe('Ontology Management', () => {
       test('should create an ontology', async ({ page }) => {
         await page.goto('/');
         await page.click('text=元本体管理');

         // 切换到本体定义Tab
         await page.click('text=本体定义');

         // 点击添加本体
         await page.click('button:has-text("添加本体")');

         // 填写本体信息
         await page.fill('input[name="name"]', 'TestEntity');
         await page.fill('textarea[name="description"]', 'Test entity description');

         // 添加属性
         await page.click('button:has-text("添加属性")');
         await page.fill('input[name="propertyName"]', 'testProp');
         await page.selectOption('select[name="propertyType"]', 'string');

         // 保存本体
         await page.click('button:has-text("保存")');

         // 验证本体出现在分类树中
         await expect(page.locator('text=TestEntity')).toBeVisible();
       });

       test('should view ontology graph', async ({ page }) => {
         await page.goto('/');
         await page.click('text=元本体管理');

         // 切换到本体关系图Tab
         await page.click('text=本体关系图');

         // 验证图谱画布存在
         await expect(page.locator('canvas')).toBeVisible();

         // 验证工具栏存在
         await expect(page.locator('button:has-text("适应画布")')).toBeVisible();
       });
     });
     ```

   - **知识图谱流程**（e2e/knowledge-graph.spec.ts）：
     ```typescript
     import { test, expect } from '@playwright/test';

     test.describe('Knowledge Graph', () => {
       test('should create a knowledge node', async ({ page }) => {
         await page.goto('/');
         await page.click('text=知识图谱');

         // 点击节点工具Tab
         await page.click('text=节点工具');

         // 选择本体类型
         await page.selectOption('select[name="ontologyType"]', { index: 0 });

         // 填写节点信息
         await page.fill('input[name="nodeName"]', 'Test Node');

         // 添加节点
         await page.click('button:has-text("添加到画布")');

         // 验证节点出现在画布中
         await expect(page.locator('canvas')).toBeVisible();
       });

       test('should create a relationship', async ({ page }) => {
         await page.goto('/');
         await page.click('text=知识图谱');

         // 点击关系工具Tab
         await page.click('text=关系工具');

         // 选择源节点和目标节点
         await page.selectOption('select[name="sourceNode"]', { index: 0 });
         await page.selectOption('select[name="targetNode"]', { index: 1 });

         // 选择关系类型
         await page.selectOption('select[name="relationType"]', { index: 0 });

         // 创建关系
         await page.click('button:has-text("创建关系")');

         // 验证关系创建成功提示
         await expect(page.locator('text=关系创建成功')).toBeVisible();
       });
     });
     ```

5. **测试命令**（package.json）：
   ```json
   {
     "scripts": {
       "test:e2e": "playwright test",
       "test:e2e:ui": "playwright test --ui",
       "test:e2e:report": "playwright show-report"
     }
   }
   ```

6. **测试覆盖目标**：
   - 模型管理：创建模型、配置模型、测试连接、编辑模型、删除模型
   - 提示词管理：编辑提示词、变量提取、测试提示词、保存提示词
   - 本体管理：创建本体、编辑本体、查看关系图、节点交互
   - 知识图谱：创建节点、创建关系、编辑节点、删除节点
   - 测试通过率：100%

**技术约束**：
- 使用Playwright
- 测试覆盖：模型管理、提示词管理、本体管理、知识图谱的核心流程
- 测试文件命名：*.spec.ts
- 测试文件位置：e2e/ 目录

**验收方案**：
- [ ] 功能验收：E2E测试可运行，核心流程测试通过，测试通过率 100%
- [ ] 交互验收：测试覆盖真实用户操作路径，包含等待和断言
- [ ] 文档验收：E2E测试命令和报告文档化，README中包含E2E测试说明

#### 任务10.3: 构建优化和Docker部署

**📋 实现功能**：生产构建优化和Docker容器化部署配置

**🎨 本次可见产出**：
- 运行 `npm run build` 生成生产构建
- 构建产物大小合理（< 2MB gzipped）
- 运行 `docker build` 可构建Docker镜像
- 运行 `docker run` 可启动容器，访问 `http://localhost` 可看到应用

**实现目标**：
优化构建配置，创建Dockerfile和部署文档

**功能详细说明**：
1. **Vite构建优化配置**（vite.config.ts）：
   ```typescript
   import { defineConfig } from 'vite';
   import react from '@vitejs/plugin-react';

   export default defineConfig({
     plugins: [react()],
     build: {
       target: 'es2015',
       outDir: 'dist',
       assetsDir: 'assets',
       sourcemap: false,
       minify: 'terser',
       terserOptions: {
         compress: {
           drop_console: true,
           drop_debugger: true
         }
       },
       rollupOptions: {
         output: {
           manualChunks: {
             'react-vendor': ['react', 'react-dom', 'react-router-dom'],
             'state-vendor': ['zustand', '@tanstack/react-query'],
             'graph-vendor': ['@antv/g6'],
             'editor-vendor': ['@monaco-editor/react']
           },
           chunkFileNames: 'assets/js/[name]-[hash].js',
           entryFileNames: 'assets/js/[name]-[hash].js',
           assetFileNames: 'assets/[ext]/[name]-[hash].[ext]'
         }
       },
       chunkSizeWarningLimit: 1000
     }
   });
   ```

2. **代码分割策略**：
   - **react-vendor**: React核心库（~150KB）
   - **state-vendor**: 状态管理库（~50KB）
   - **graph-vendor**: G6图谱库（~500KB）
   - **editor-vendor**: Monaco编辑器（~800KB）
   - 其他业务代码按路由懒加载

3. **路由懒加载**（App.tsx）：
   ```typescript
   import { lazy, Suspense } from 'react';
   import { BrowserRouter, Routes, Route } from 'react-router-dom';

   const Model = lazy(() => import('./pages/Model'));
   const Prompt = lazy(() => import('./pages/Prompt'));
   const Ontology = lazy(() => import('./pages/Ontology'));
   const Knowledge = lazy(() => import('./pages/Knowledge'));

   function App() {
     return (
       <BrowserRouter>
         <Suspense fallback={<div>Loading...</div>}>
           <Routes>
             <Route path="/model" element={<Model />} />
             <Route path="/prompt" element={<Prompt />} />
             <Route path="/ontology" element={<Ontology />} />
             <Route path="/knowledge" element={<Knowledge />} />
           </Routes>
         </Suspense>
       </BrowserRouter>
     );
   }
   ```

4. **Dockerfile**（多阶段构建）：
   ```dockerfile
   # Stage 1: Build
   FROM node:20-alpine AS builder

   WORKDIR /app

   # 复制package文件
   COPY package.json pnpm-lock.yaml ./

   # 安装pnpm
   RUN npm install -g pnpm

   # 安装依赖
   RUN pnpm install --frozen-lockfile

   # 复制源代码
   COPY . .

   # 构建应用
   RUN pnpm run build

   # Stage 2: Production
   FROM nginx:alpine

   # 复制构建产物
   COPY --from=builder /app/dist /usr/share/nginx/html

   # 复制nginx配置
   COPY nginx.conf /etc/nginx/conf.d/default.conf

   # 暴露端口
   EXPOSE 80

   # 启动nginx
   CMD ["nginx", "-g", "daemon off;"]
   ```

5. **Nginx配置**（nginx.conf）：
   ```nginx
   server {
       listen 80;
       server_name localhost;
       root /usr/share/nginx/html;
       index index.html;

       # Gzip压缩
       gzip on;
       gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
       gzip_min_length 1000;

       # SPA路由支持
       location / {
           try_files $uri $uri/ /index.html;
       }

       # 静态资源缓存
       location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
           expires 1y;
           add_header Cache-Control "public, immutable";
       }

       # API代理（如果需要）
       location /api {
           proxy_pass http://backend:8000;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
       }
   }
   ```

6. **Docker Compose配置**（docker-compose.yml）：
   ```yaml
   version: '3.8'

   services:
     frontend:
       build:
         context: .
         dockerfile: Dockerfile
       ports:
         - "80:80"
       environment:
         - NODE_ENV=production
       restart: unless-stopped

     # 如果有后端服务
     # backend:
     #   image: backend:latest
     #   ports:
     #     - "8000:8000"
     #   environment:
     #     - DATABASE_URL=postgresql://...
   ```

7. **环境变量配置**（.env.production）：
   ```bash
   VITE_API_BASE_URL=https://api.example.com
   VITE_APP_TITLE=心理分析系统
   VITE_ENABLE_MOCK=false
   ```

8. **构建和部署命令**：
   ```bash
   # 本地构建
   npm run build

   # 预览构建产物
   npm run preview

   # Docker构建
   docker build -t psychanalysis-frontend:latest .

   # Docker运行
   docker run -d -p 80:80 --name psychanalysis-frontend psychanalysis-frontend:latest

   # Docker Compose运行
   docker-compose up -d
   ```

9. **构建产物大小优化目标**：
   - **总大小**（gzipped）：< 2MB
   - **首屏JS**：< 300KB
   - **首屏CSS**：< 50KB
   - **图谱库**（懒加载）：< 500KB
   - **编辑器**（懒加载）：< 800KB

10. **部署文档**（DEPLOYMENT.md）：
    ```markdown
    # 部署文档

    ## 环境要求
    - Node.js 20.x
    - Docker 20.x
    - pnpm 9.x

    ## 本地构建
    1. 安装依赖：`pnpm install`
    2. 构建应用：`pnpm run build`
    3. 预览构建：`pnpm run preview`

    ## Docker部署
    1. 构建镜像：`docker build -t psychanalysis-frontend:latest .`
    2. 运行容器：`docker run -d -p 80:80 psychanalysis-frontend:latest`
    3. 访问应用：http://localhost

    ## 环境变量
    - `VITE_API_BASE_URL`: 后端API地址
    - `VITE_APP_TITLE`: 应用标题
    - `VITE_ENABLE_MOCK`: 是否启用Mock数据

    ## 性能指标
    - 首屏加载时间：< 3s
    - 构建产物大小：< 2MB (gzipped)
    - Lighthouse评分：> 90
    ```

**技术约束**：
- 使用Vite的代码分割和Tree Shaking
- Dockerfile使用多阶段构建
- Nginx配置Gzip压缩和静态资源缓存
- 构建产物大小 < 2MB (gzipped)

**验收方案**：
- [ ] 功能验收：构建成功，Docker镜像可运行，应用可正常访问
- [ ] 性能验收：首屏加载时间 < 3s，构建产物大小 < 2MB (gzipped)，Lighthouse评分 > 90
- [ ] 文档验收：部署文档完整，包含环境变量说明、构建命令、部署步骤

---

## 附录

### 附录A: 技术栈清单

| 类别 | 技术 | 版本 | 用途 |
|------|------|------|------|
| 框架 | React | 19.x | UI框架 |
| 构建工具 | Vite | 6.x | 开发和构建 |
| 语言 | TypeScript | 5.8.x | 类型安全 |
| 样式 | Tailwind CSS | 3.x | 样式方案 |
| 路由 | React Router | 7.x | 路由管理 |
| 状态管理 | Zustand | 5.x | 全局状态 |
| 数据请求 | TanStack Query | 5.x | 服务端状态 |
| 图可视化 | @antv/g6 | 4.8.x | 图谱渲染 |
| 代码编辑器 | Monaco Editor | 0.52.x | 代码编辑 |
| 图标 | Lucide React | 最新 | 图标库 |
| 测试 | Vitest + Playwright | 最新 | 单元测试+E2E |

### 附录B: 参考文档索引

- **D1**: 心理分析系统_前端架构设计_v1.0.md
- **D2**: 心理分析系统_P0阶段交互需求设计_v1.0.md
- **D3**: 心理分析系统_API接口协议文档_v1.0.md

### 附录C: 开发环境要求

- Node.js: 20.x
- pnpm: 9.x
- 操作系统: Windows/macOS/Linux
- 浏览器: Chrome/Edge/Firefox 最新版

---

**文档结束**

